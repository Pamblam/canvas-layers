<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 3.6.2">
  <meta charset="utf-8">
  <title>Source: canvas-layers.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: canvas-layers.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>/**
 * canvas-layers - v1.2.31
 * Allow user to position and re-arrange images on a canvas.
 * @author Pamblam
 * @website 
 * @license MIT
 */


/**
 * Interface for handling all canvas functionality
 * @see https://pamblam.github.io/canvas-layers/examples/
 * @version 1.2.31
 */
class Canvas{
	
	/**
	 * Construct a new instance of the Canvas class
	 * @param {HTMLElement} canvas - The canvas to instantiate the class upon.
	 * @param {Number} [opts.anchorRadius&#x3D;Canvas.anchorRadius] - The radius of the anchor points shown on selected elements.
	 * @param {String} [opts.strokeStyle&#x3D;Canvas.strokeStyle] - The color of the outlines drawn on selceted elements. May be any valid CSS color string.
	 * @param {String} [opts.fillStyle&#x3D;Canvas.fillStyle] - The color of the anchor points shown on selected elements. May be any valid CSS color string.
	 * @param {Number} [opts.lineWidth&#x3D;Canvas.lineWidth] - The width of the outlines shown on selected elements.
	 * @param {String} [opts.cursors.default&#x3D;Canvas.cursors.default] - The default cursor to use when hovering over the canvas. May be any valid css cursor value.
	 * @param {String} [opts.cursors.grab&#x3D;Canvas.cursors.grab] - The grab cursor to use when hovering over a movable layer. May be any valid css cursor value.
	 * @param {String} [opts.cursors.grabbing&#x3D;Canvas.cursors.grabbing] - The grabbing cursor to use when dragging a layer. May be any valid css cursor value.
	 * @param {String} [opts.cursors.move&#x3D;Canvas.cursors.move] - The default cursor to use when hovering over a resize anchor. May be any valid css cursor value.
	 * @param {String} [opts.cursors.rotate&#x3D;Canvas.cursors.rotate] - The default cursor to use when hovering a rotate anchor point. May be any valid css cursor value.
	 * @param {String} [opts.cursors.rotating&#x3D;Canvas.cursors.rotating] - The default cursor to use when rotating an active layer. May be any valid css cursor value.
	 * @returns {Canvas}
	 */
	constructor(canvas, opts&#x3D;{}){
		this.canvas &#x3D; canvas;
		this.width &#x3D; canvas.width;
		this.height &#x3D; canvas.height;
		this.ctx &#x3D; canvas.getContext(&#x27;2d&#x27;);
		this.layers &#x3D; [];
		this.layer_state_pos &#x3D; -1;
		this.layer_states &#x3D; [];
		this.drawPromises &#x3D; [];
		this.activeLayer &#x3D; null;
		this.shiftKeyDown &#x3D; false;
		this.draggingActiveLayer &#x3D; false;
		this.resizingActiveLayer &#x3D; false;
		this.rotatingActiveLayer &#x3D; false;
		this.lastMouseDownOffset &#x3D; {x:0, y:0};
		this.activeLayerMouseOffset &#x3D; {x:0, y:0};
		this.activeLayerOriginalDimensions &#x3D; {width:0, height:0};
		this.activeLayerRotateStartPos &#x3D; {x:0, y:0};
		this.displayGrid &#x3D; false;
		this.snapToGrid &#x3D; false;
		this.gridDistancePixels &#x3D; 10;
		
		canvas.addEventListener(&#x27;mousemove&#x27;, this.onmousemove.bind(this));
		canvas.addEventListener(&#x27;mousedown&#x27;, this.onmousedown.bind(this));
		canvas.addEventListener(&#x27;mouseout&#x27;, this.onmousereset.bind(this));
		canvas.addEventListener(&#x27;mouseup&#x27;, this.onmousereset.bind(this));
		canvas.addEventListener(&#x27;click&#x27;, this.onclick.bind(this));
		canvas.addEventListener(&#x27;dblclick&#x27;, this.ondblclick.bind(this));
		document.addEventListener(&#x27;keydown&#x27;, this.onkeyevent.bind(this));
		document.addEventListener(&#x27;keyup&#x27;, this.onkeyevent.bind(this));
		
		this.anchorRadius &#x3D; opts.anchorRadius || Canvas.anchorRadius;
		this.strokeStyle &#x3D; opts.strokeStyle || Canvas.strokeStyle;
		this.fillStyle &#x3D; opts.fillStyle || Canvas.fillStyle;
		this.lineWidth &#x3D; opts.lineWidth || Canvas.lineWidth;
		this.cursors &#x3D; opts.cursors || {};
		this.cursors.default &#x3D; this.cursors.default || Canvas.cursors.default;
		this.cursors.grab &#x3D; this.cursors.grab || Canvas.cursors.grab;
		this.cursors.grabbing &#x3D; this.cursors.grabbing || Canvas.cursors.grabbing;
		this.cursors.move &#x3D; this.cursors.move || Canvas.cursors.move;
		this.cursors.rotate &#x3D; this.cursors.rotate || Canvas.cursors.rotate;
		this.cursors.rotating &#x3D; this.cursors.rotating || Canvas.cursors.rotating;
		this.last_clicked_layer &#x3D; null;
		this.pending_layers &#x3D; 0;
		this.ready &#x3D; true;
		
		// if turned on, no state will be saved.
		this.muteStateChanges &#x3D; false;
		this.isCtrlPressed &#x3D; false;
		this.ctrlGroupLayer &#x3D; new CanvasLayerGroup(&#x27;ctrl-grp&#x27;);
	}	
	
	/**
	 * Is the provided layer part of the ctrl-grp
	 * @param {CavnasLayer} layer
	 * @returns {Boolean}
	 */
	isLayerInGroup(layer){
		return !!~this.ctrlGroupLayer.layers.indexOf(layer);
	}
	
	/**
	 * Is the ctrl-grp on the canvas?
	 * @returns {Boolean}
	 */
	isGroupOnCanvas(){ 
		return !!~this.layers.indexOf(this.ctrlGroupLayer) 
	}
	
	/**
	 * Remove the ctrl-grp from the canvas
	 * @returns {Promise}
	 */
	async destroyCtrlGroup(){
		this.muteStateChanges &#x3D; true;
		var promises &#x3D; this.ctrlGroupLayer.layers.map(layer&#x3D;&gt;{
			return new Promise(done&#x3D;&gt;{
				this.addLayer(layer);
				layer.onload(()&#x3D;&gt;done());
			});
		});
		await Promise.all(promises);
		this.ctrlGroupLayer.layers &#x3D; [];
		this.ctrlGroupLayer.rotation &#x3D; 0;
		if(this.isGroupOnCanvas()) this.removeLayer(this.ctrlGroupLayer);
		this.muteStateChanges &#x3D; false;
	}
	
	/**
	 * Load the state object
	 * @param {type} state
	 * @returns {undefined}
	 */
	loadState(state){
		this.layers &#x3D; state.map(s&#x3D;&gt;CanvasLayer.deobjectify(s));
		this.draggingActiveLayer &#x3D; false;
		this.resizingActiveLayer &#x3D; false;
		this.rotatingActiveLayer &#x3D; false;
		this.lastMouseDownOffset &#x3D; {x:0, y:0};
		this.activeLayerMouseOffset &#x3D; {x:0, y:0};
		this.activeLayerOriginalDimensions &#x3D; {width:0, height:0};
		this.activeLayerRotateStartPos &#x3D; {x:0, y:0};
		this.draw();
	}
	
	/**
	 * saves the current state in the state stack
	 * @returns {undefined}
	 */
	saveState(){
		if(this.muteStateChanges) return;
		var state &#x3D; [];
		const getState &#x3D; (layers) &#x3D;&gt; {
			layers.forEach(layer&#x3D;&gt;{
				if(layer instanceof CanvasLayerGroup) getState(layer.layers);
				else state.push(layer.objectify());
			});
		}
		getState(this.layers);
		this.layer_states.length &#x3D; this.layer_state_pos+1;
		this.layer_states.push(state);
		this.layer_state_pos &#x3D; this.layer_states.length-1;
	}
	
	/**
	 * Undo an action
	 * @returns {undefined}
	 */
	undo(){
		if(this.layer_state_pos&gt;0){
			this.layer_state_pos--;
			this.loadState(this.layer_states[this.layer_state_pos]);
		}
	}
	
	/**
	 * Redo the last un-did action
	 * @returns {undefined}
	 */
	redo(){
		if((this.layer_state_pos+1)&amp;lt;this.layer_states.length){
			this.layer_state_pos++;
			this.loadState(this.layer_states[this.layer_state_pos]);
		}
	}
	
	/**
	 * Enable snap to grid
	 * @returns {undefined}
	 */
	snapOn(gridDistancePixels&#x3D;10){
		this.snapToGrid &#x3D; true;
		gridDistancePixels &#x3D; +gridDistancePixels &amp;lt; 3 ? 3 : +gridDistancePixels;
		this.gridDistancePixels &#x3D; gridDistancePixels;
	}
	
	/**
	 * Disable snap to grid
	 * @returns {undefined}
	 */
	snapOff(){
		this.snapToGrid &#x3D; false;
		this.draw();
	}
	
	/**
	 * Show the grid lines on the canvas
	 * @returns {undefined}
	 */
	showGrid(gridDistancePixels&#x3D;10){
		this.displayGrid &#x3D; true;
		gridDistancePixels &#x3D; +gridDistancePixels &amp;lt; 3 ? 3 : +gridDistancePixels;
		this.gridDistancePixels &#x3D; gridDistancePixels;
		this.draw();
	}
	
	/**
	 * Hide the grid lines on the canvas
	 * @returns {undefined}
	 */
	hideGrid(){
		this.displayGrid &#x3D; false;
		this.draw();
	}
	
	/**
	 * Get a layer by it&#x27;s given name.
	 * @param {String} name - The name of the layer. 
	 * @returns {CanvasLayer|null}
	 */
	getLayerByName(name){
		for(var i&#x3D;this.layers.length; i--;){
			if(this.layers[i].name &#x3D;&#x3D;&#x3D; name) return this.layers[i];
		}
		return null;
	}
	
	/**
	 * Add a layer to the canvas.
	 * @param {String} url - The URI or URL of an image to draw on the canvas.
	 * @param {String} [opts.name&#x3D;&quot;Layer n&quot;] - The name of the layer.
	 * @param {Number} [opts.x&#x3D;this.width/2] - The x position of the layer.
	 * @param {Number} [opts.y&#x3D;this.height/2] - The y position of the layer.
	 * @param {Number} [opts.rotation&#x3D;0] - The rotation of the layer, counter-clockwise, in degrees.
	 * @param {Boolean} [opts.draggable&#x3D;true] - Can the user move this layer?
	 * @param {Boolean} [opts.rotateable&#x3D;true] - Can the user rotate this layer?
	 * @param {Boolean} [opts.resizable&#x3D;true] - Can the user resize this layer?
	 * @param {Boolean} [opts.selectable&#x3D;true] - Can the user select this layer?
	 * @param {Number} [opts.width&#x3D;null] - The width of the layer to be drawn. If not specified, defaults to the images natural width.
	 * @param {Number} [opts.height&#x3D;null] - The height of the layer to be drawn. If not specified, defaults to the images natural height.
	 * @param {Boolean} [opts.forceBoundary&#x3D;false] - Force the item to stay in bounds.
	 * @param {Boolean} [opts.allowOverlap&#x3D;true] - Allow layers to overlap with this one.
	 * @returns {CanvasLayer} - The layer that was added.
	 */
	addLayer(layerOrURL, opts&#x3D;{}){
		this.ready &#x3D; false;
		if(layerOrURL instanceof CanvasLayer){
			var layer &#x3D; layerOrURL;
		}else{
			const name &#x3D; opts.name || &#x60;Layer ${this.layers.length}&#x60;;
			const x &#x3D; parseFloat(opts.x || this.width/2);
			const y &#x3D; parseFloat(opts.y || this.height/2);
			const rotation &#x3D; parseFloat(opts.rotation || 0);
			const draggable &#x3D; opts.draggable &#x3D;&#x3D;&#x3D; undefined ? true : opts.draggable;
			const rotateable &#x3D; !!opts.rotateable &#x3D;&#x3D;&#x3D; undefined ? true : opts.rotateable;
			const resizable &#x3D; !!opts.resizable &#x3D;&#x3D;&#x3D; undefined ? true : opts.resizable;
			const selectable &#x3D; !!opts.selectable &#x3D;&#x3D;&#x3D; undefined ? true : opts.selectable;
			const width &#x3D; opts.width || null;
			const height &#x3D; opts.height || null;
			const forceBoundary &#x3D; opts.forceBoundary || false;
			const allowOverlap &#x3D; opts.hasOwnProperty(&#x27;allowOverlap&#x27;) ? !!opts.allowOverlap : true;
			var layer &#x3D; new CanvasLayer(layerOrURL, name, x, y, width, height, rotation, draggable, rotateable, resizable, selectable, forceBoundary, allowOverlap);
		}
		
		if(!(layer instanceof CanvasLayerGroup)){
			this.fireEvent(&#x27;layer-added&#x27;);
		}
		
		this.layers.unshift(layer);
		this.pending_layers++;
		layer.onload(()&#x3D;&gt;{
			this.pending_layers--;
			if(0 &#x3D;&#x3D;&#x3D; this.pending_layers){
				this.ready &#x3D; true;
				this.draw();
				this.saveState();
			}
		});
		return layer;
	}
	
	/**
	 * Rotate and crop the canvas to the dimensions and rotation of the specified layer.
	 * @param {CanvasLayer} layer - The layer to crop to.
	 * @returns {Promise} - A Promise htat resolves with the DataURI of the cropped area.
	 */
	cropToLayer(layer, unrotated&#x3D;true){
		return this.extractPortion(layer.x, layer.y, layer.width, layer.height, layer.rotation, unrotated);
	}
	
	/**
	 * Rotate and extract a custom area of the canvas.
	 * @param {Number} centerx - The x position of the center of the area to extract.
	 * @param {Number} centery - The y position of the center of the area to extract.
	 * @param {Number} width - The width of the area to extract from teh canvas.
	 * @param {Number} height - The height of the area to extract from teh canvas.
	 * @param {Number} [rotation&#x3D;0] - The rotation of the area to extract, counter-clockwise, in degrees.
	 * @param {Boolean} [unrotated&#x3D;true] - If true, undo the rotation so the layer is in it&#x27;s natural position.
	 * @returns {Promise} - A Promise htat resolves with the DataURI of the cropped area.
	 */
	async extractPortion(centerx, centery, width, height, rotation&#x3D;0, unrotated&#x3D;true){
		var radians &#x3D; rotation * Math.PI / 180;
		var {x, y} &#x3D; Canvas.absolutePoint(-(width/2), -(height/2), centerx, centery, rotation);
		
		var rectBB &#x3D; this.getRotatedRectBB(x, y, width, height, radians);
		
		var canvas0 &#x3D; document.createElement(&quot;canvas&quot;);
		var ctx0 &#x3D; canvas0.getContext(&quot;2d&quot;);
		var canvas1 &#x3D; document.createElement(&quot;canvas&quot;);
		var ctx1 &#x3D; canvas1.getContext(&quot;2d&quot;);
		var canvas2 &#x3D; document.createElement(&quot;canvas&quot;);
		var ctx2 &#x3D; canvas2.getContext(&quot;2d&quot;);
		
		canvas1.width &#x3D; canvas2.width &#x3D; rectBB.width;
		canvas1.height &#x3D; canvas2.height &#x3D; rectBB.height;
		canvas0.width &#x3D; this.width;
		canvas0.height &#x3D; this.height;
		
		await this.loadAll();
		
		for(let i&#x3D;this.layers.length; i--;){
			let layer &#x3D; this.layers[i];
			var radians &#x3D; layer.rotation * (Math.PI/180);
			ctx0.translate(layer.x, layer.y);
			ctx0.rotate(radians);
			ctx0.drawImage(layer.image, -(layer.width/2), -(layer.height/2), layer.width, layer.height);
			ctx0.rotate(-radians);
			ctx0.translate(-layer.x, -layer.y);
		}

		ctx1.drawImage(canvas0, rectBB.cx - rectBB.width / 2, rectBB.cy - rectBB.height / 2, rectBB.width, rectBB.height, 0, 0, rectBB.width, rectBB.height);
		
		if(!unrotated){
			return canvas1.toDataURL();
		}
		
		ctx2.translate(canvas1.width / 2, canvas1.height / 2);
		ctx2.rotate(-radians);
		ctx2.drawImage(canvas1, -canvas1.width / 2, -canvas1.height / 2);
		var ofstx &#x3D; (canvas2.width - width) / 2;
		var ofsty &#x3D; (canvas2.height - height) / 2;
		ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
		canvas1.width &#x3D; width;
		canvas1.height &#x3D; height;
		ctx1.drawImage(canvas2, -ofstx, -ofsty);
		return canvas1.toDataURL();
	}
	
	
	/**
	 * Draw the canvas.
	 * @returns {Promise}
	 */
	draw(){
		return new Promise(done&#x3D;&gt;{
			this.drawPromises.push(done);
			if(!this.ready) return;

			this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
			for(let i&#x3D;this.layers.length; i--;){
				let layer &#x3D; this.layers[i];
				var radians &#x3D; layer.rotation * (Math.PI/180);
				this.ctx.translate(layer.x, layer.y);
				this.ctx.rotate(radians);

				this.ctx.drawImage(layer.image, -(layer.width/2), -(layer.height/2), layer.width, layer.height);

				if(layer &#x3D;&#x3D;&#x3D; this.activeLayer){
					this.ctx.strokeStyle &#x3D; this.strokeStyle;
					this.ctx.fillStyle &#x3D; this.fillStyle;
					this.ctx.lineWidth &#x3D; this.getScale() * this.lineWidth;
					this.ctx.strokeRect(-(layer.width/2), -(layer.height/2), layer.width, layer.height);
					if(layer.resizable){
						layer.getCorners().forEach(corner&#x3D;&gt;{
							this.drawCircle(corner.x, corner.y, this.getScale() * this.anchorRadius);
						});
					}
					if(layer.rotateable){
						this.ctx.beginPath();
						this.ctx.moveTo(0, 0);
						this.ctx.lineTo((layer.width/2)+25, 0);
						this.ctx.stroke();
						this.drawCircle((layer.width/2)+25, 0, this.getScale() * this.anchorRadius);
					}
				}
				this.ctx.rotate(-radians);
				this.ctx.translate(-layer.x, -layer.y);
			}

			if(this.displayGrid){
				this.ctx.strokeStyle &#x3D; &quot;rgba(0,0,0,0.2)&quot;;
				this.ctx.lineWidth &#x3D; this.getScale() * 2;
				var {xs, ys} &#x3D; this.getGridLines(false);
				xs.forEach(x&#x3D;&gt;{
					this.ctx.beginPath();
					this.ctx.moveTo(x, 0);
					this.ctx.lineTo(x, this.canvas.height);
					this.ctx.stroke(); 
				});
				ys.forEach(y&#x3D;&gt;{
					this.ctx.beginPath();
					this.ctx.moveTo(0, y);
					this.ctx.lineTo(this.canvas.width, y);
					this.ctx.stroke(); 
				});
			}
			
			while(this.drawPromises.length) this.drawPromises.shift()();
		});
	}	
	
	/**
	 * Remove all layers from teh canvas.
	 * @returns {undefined}
	 */
	removeAllLayers(){
		this.deSelectLayer();
		this.layers &#x3D; [];
		this.draw();
	}
	
	/**
	 * Remove the specified layer from the canvas.
	 * @param {CanvasLayer} layer - The layer to remove
	 * @returns {undefined}
	 */
	removeLayer(layer){
		if(layer &#x3D;&#x3D;&#x3D; this.activeLayer) this.deSelectLayer();
		this.layers.splice(this.layers.indexOf(layer), 1);
		this.saveState();
		this.draw();
	}
	
	/**
	 * Select the given layer.
	 * @param {CanvasLayer} layer - The layer to select.
	 * @returns {undefined}
	 */
	selectLayer(layer){
		this.layers.unshift(this.layers.splice(this.layers.indexOf(layer), 1)[0]);
		this.activeLayer &#x3D; layer;
		this.draw();
		this.fireEvent(&#x27;layer-selected&#x27;);
	}
	
	/**
	 * Deselect the selected layer if one is selected.
	 * @returns {undefined}
	 */
	deSelectLayer(){
		this.activeLayer &#x3D; null;
		this.draggingActiveLayer &#x3D; false;
		this.draw();
		this.fireEvent(&#x27;layer-deselected&#x27;);
	}
	
	/**
	 * Get the cooresponding coordinates of the mouses position on the canvas.
	 * @param {MouseEvent} e - The event passed to a mouse event handler.
	 * @returns {{x: Number, y: Number}}
	 */
	canvasMousePos(e) {
		var rect &#x3D; this.canvas.getBoundingClientRect();
		var x &#x3D; e.clientX - rect.left;
		var y &#x3D; e.clientY - rect.top;
		var wfactor &#x3D; this.canvas.width / rect.width;
		var hfactor &#x3D; this.canvas.height / rect.height;
		x &#x3D; x*wfactor;
		y &#x3D; y*hfactor;
		return {x, y};
	}
	
	/**
	 * Get the layer at the given canvas coordinates.
	 * @param {Number} x - The x ordinate.
	 * @param {Number} y - The y ordinate.
	 * @returns {CanvasLayer|null}
	 */
	getLayerAt(x, y){
		for(let i&#x3D;0; i&amp;lt;this.layers.length; i++){
			let layer &#x3D; this.layers[i];
			if(Canvas.isOverLayer(x, y, layer)) return layer;
		}
		return null;
	}
	
	/**
	 * Are the given coordinates over a selectable layer?
	 * @param {Number} x - The x ordinate.
	 * @param {Number} y - The y ordinate.
	 * @returns {Boolean}
	 */
	isOverSelectableLayer(x, y){
		for(let i&#x3D;this.layers.length; i--;){
			if(Canvas.isOverLayer(x, y, this.layers[i])){
				if(this.layers[i].selectable &amp;amp;&amp;amp; this.activeLayer !&#x3D;&#x3D; this.layers[i]) return true;
			}
		}
		return false;
	}
	
	/**
	 * Get an array of all layers that the given layer overlaps.
	 * @param {type} layer
	 * @returns {Array|Canvas.getOverlappingLayers.layers}
	 */
	getOverlappingLayers(layer){
		var layers &#x3D; [];
		for(var i&#x3D;0; i&amp;lt;this.layers.length; i++){
			if(this.layers[i] &#x3D;&#x3D;&#x3D; layer) continue;
			if(this.doLayersOverlap(layer, this.layers[i])){
				layers.push(this.layers[i]);
			}
		}
		return layers;
	}
	
	////////////////////////////////////////////////////////////////////////////
	// Undocumented utility layers /////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////
	
	/**
	 * Get an object containing arrays of x and y grid line positons
	 * @param {Boolean} snap - If true, get lines to snap to, else get lines to display
	 * @returns {Object} - An object with an &#x27;xs&#x27; property containing x positions and a &#x27;ys&#x27; property containing y positions;
	 */
	getGridLines(snap&#x3D;true){
		var xs &#x3D; [];
		var ys &#x3D; [];
		var dist &#x3D; 0;
		
		if(snap){
			dist &#x3D; this.gridDistancePixels;
		}else{
			dist &#x3D; this.gridDistancePixels * 2;
		}
		
		for(var x&#x3D;0; x&amp;lt;this.canvas.width; x +&#x3D; (this.getScale() * dist)){
			xs.push(x); 
		}
		for(var y&#x3D;0; y&amp;lt;this.canvas.height; y +&#x3D; (this.getScale() * dist)){
			ys.push(y);
		}
		for(let i&#x3D;this.layers.length; i--;){
			if(snap &amp;amp;&amp;amp; this.layers[i] &#x3D;&#x3D;&#x3D; this.activeLayer) continue;
			xs.push(this.layers[i].x);
			ys.push(this.layers[i].y);
		}
		[...new Set(xs)].sort();
		[...new Set(ys)].sort();
		return {xs, ys};
	}
	
	/**
	 * Load all layers.
	 * @ignore
	 */
	loadAll(){
		var promises &#x3D; this.layers.map(layer&#x3D;&gt;layer.load());
		return Promise.all(promises);
	}
	
	/**
	 * Get the bounding box of the defined area.
	 * @ignore
	 */
	getRotatedRectBB(x, y, width, height, rAngle) {
		var absCos &#x3D; Math.abs(Math.cos(rAngle));
		var absSin &#x3D; Math.abs(Math.sin(rAngle));
		var cx &#x3D; x + width / 2 * Math.cos(rAngle) - height / 2 * Math.sin(rAngle);
		var cy &#x3D; y + width / 2 * Math.sin(rAngle) + height / 2 * Math.cos(rAngle);
		var w &#x3D; width * absCos + height * absSin;
		var h &#x3D; width * absSin + height * absCos;
		return ({
			cx: cx,
			cy: cy,
			width: w,
			height: h
		});
	}
	
	/**
	 * Draw a circle on the canvas.
	 * @ignore
	 */
	drawCircle(x, y, radius){
		this.ctx.beginPath();
		this.ctx.arc(x, y, radius, 0, Math.PI*2, true); 
		this.ctx.closePath();
		this.ctx.fill();
	}
	
	/**
	 * Handle key down and keyup.
	 * @ignore
	 */
	onkeyevent(e){
		if(&#x27;Shift&#x27; &#x3D;&#x3D;&#x3D; e.key){
			if(e.type &#x3D;&#x3D;&#x3D; &#x27;keydown&#x27;) this.shiftKeyDown &#x3D; true;
			else this.shiftKeyDown &#x3D; false
		}
		if(&#x27;Control&#x27; &#x3D;&#x3D;&#x3D; e.key){
			if(e.type &#x3D;&#x3D;&#x3D; &#x27;keydown&#x27;) this.isCtrlPressed &#x3D; true;
			else this.isCtrlPressed &#x3D; false
		}
		if(!this.isCtrlPressed &amp;amp;&amp;amp; this.isGroupOnCanvas()){
			this.destroyCtrlGroup();
		}
	}
	
	/**
	 * Check if two given layers overlap
	 * @param {CanvasLayer} layer1
	 * @param {CanvasLayer} layer2
	 * @returns {Boolean}
	 */
	doLayersOverlap(layer1, layer2){
		const abs_corners &#x3D; l &#x3D;&gt; l.getCorners().map(c&#x3D;&gt;Canvas.absolutePoint(c.x, c.y, l.x, l.y, l.rotation));
		const corners_to_lines &#x3D; c &#x3D;&gt; [
			[{x:c[0].x, y:c[0].y},{x:c[1].x, y:c[1].y}],
			[{x:c[1].x, y:c[1].y},{x:c[2].x, y:c[2].y}],
			[{x:c[2].x, y:c[2].y},{x:c[3].x, y:c[3].y}],
			[{x:c[3].x, y:c[3].y},{x:c[0].x, y:c[0].y}]
		];
		
		var l1_corners &#x3D; abs_corners(layer1);
		var l1_lines &#x3D; corners_to_lines(l1_corners);
		
		var l2_corners &#x3D; abs_corners(layer2);
		var l2_lines &#x3D; corners_to_lines(l2_corners);
		
		// Check if any of the edges intersect
		// This covers partial overlaps.
		for(let n1&#x3D;0; n1&amp;lt;l1_lines.length; n1++){
			for(let n2&#x3D;0; n2&amp;lt;l2_lines.length; n2++){
				let a &#x3D; l1_lines[n1][0].x;
				let b &#x3D; l1_lines[n1][0].y;
				let c &#x3D; l1_lines[n1][1].x;
				let d &#x3D; l1_lines[n1][1].y;
				let p &#x3D; l2_lines[n2][0].x;
				let q &#x3D; l2_lines[n2][0].y;
				let r &#x3D; l2_lines[n2][1].x;
				let s &#x3D; l2_lines[n2][1].y;
				if(Canvas.doLinesIntersect(a, b, c, d, p, q, r, s)) return true;
			}
		}
		
		return false;
	}
	
	/**
	 * Returns true if the active layer can be moved to the specified coordinates.
	 * @ignore
	 */
	canMoveActiveLayer(newx, newy){
		const inBounds &#x3D; this.isNewPosInBounds(this.activeLayer, newx, newy, this.activeLayer.width, this.activeLayer.height);
		if(this.activeLayer.forceBoundary &amp;amp;&amp;amp; !inBounds) return false;
		
		var x &#x3D; this.activeLayer.x;
		var y &#x3D; this.activeLayer.y;
		this.activeLayer.x &#x3D; newx;
		this.activeLayer.y &#x3D; newy;
		
		var canMove &#x3D; true;
		for(var i&#x3D;0; i&amp;lt;this.layers.length; i++){
			if(this.layers[i] &#x3D;&#x3D;&#x3D; this.activeLayer) continue;
			if(this.activeLayer.allowOverlap &amp;amp;&amp;amp; this.layers[i].allowOverlap) continue;
			if(this.doLayersOverlap(this.activeLayer, this.layers[i])){
				canMove &#x3D; false;
				break;
			}
		}
		
		this.activeLayer.x &#x3D; x;
		this.activeLayer.y &#x3D; y;
		
		return canMove;
	}
	
	/**
	 * Returns true if the active layer can be resized to the specified dimensions.
	 * @ignore
	 */
	canResizeActiveLayer(width, height){
		const inBounds &#x3D; this.isNewPosInBounds(this.activeLayer, this.activeLayer.x, this.activeLayer.y, width, height);
		if(this.activeLayer.forceBoundary &amp;amp;&amp;amp; !inBounds) return false;
		
		var w &#x3D; this.activeLayer.width;
		var h &#x3D; this.activeLayer.height;
		this.activeLayer.width &#x3D; w;
		this.activeLayer.height &#x3D; h;
		
		var canResize &#x3D; true;
		for(var i&#x3D;0; i&amp;lt;this.layers.length; i++){
			if(this.layers[i] &#x3D;&#x3D;&#x3D; this.activeLayer) continue;
			if(this.activeLayer.allowOverlap &amp;amp;&amp;amp; this.layers[i].allowOverlap) continue;
			if(this.doLayersOverlap(this.activeLayer, this.layers[i])){
				canResize &#x3D; false;
				break;
			}
		}
		
		this.activeLayer.width &#x3D; w;
		this.activeLayer.height &#x3D; h;
		
		return canResize;
	}
	
	/**
	 * Returns true if the active layer can be rotated to the specified degree.
	 * @ignore
	 */
	canRotateActiveLayer(degrees){
		var r &#x3D; this.activeLayer.rotation;
		this.activeLayer.rotation &#x3D; degrees;
		
		const inBounds &#x3D; this.isNewPosInBounds(this.activeLayer, this.activeLayer.x, this.activeLayer.y, this.activeLayer.width, this.activeLayer.height);
		if(this.activeLayer.forceBoundary &amp;amp;&amp;amp; !inBounds) return false;
		
		var canRotate &#x3D; true;
		for(var i&#x3D;0; i&amp;lt;this.layers.length; i++){
			if(this.layers[i] &#x3D;&#x3D;&#x3D; this.activeLayer) continue;
			if(this.activeLayer.allowOverlap &amp;amp;&amp;amp; this.layers[i].allowOverlap) continue;
			if(this.doLayersOverlap(this.activeLayer, this.layers[i])){
				canRotate &#x3D; false;
				break;
			}
		}
		
		this.activeLayer.rotation &#x3D; r;
		
		return canRotate;
	}
	
	/**
	 * Handle mouse moves over the canvas.
	 * @ignore
	 */
	onmousemove(e){
		var {x, y} &#x3D; this.canvasMousePos(e);
		this.setCursor(x, y);
		if(this.activeLayer &#x3D;&#x3D;&#x3D; null) return;
		
		if(this.rotatingActiveLayer){
			
			var dx &#x3D; x - this.activeLayer.x;
			var dy &#x3D; y - this.activeLayer.y;
			var angle &#x3D; Math.atan2(dy, dx);
			var degrees &#x3D; angle * 180 / Math.PI;
			
			if(!this.canRotateActiveLayer(degrees)){
				this.rotatingActiveLayer &#x3D; false;
				this.draw();
				return;
			}
			
			if(this.fireEvent(&#x27;layer-rotate&#x27;)){
				this.activeLayer.rotation &#x3D; degrees;
				if(this.activeLayer instanceof CanvasLayerGroup){
					this.activeLayer.updateLayers();
				}
				this.draw();
			}
		}else if(this.draggingActiveLayer){
			const newx &#x3D; this.activeLayerMouseOffset.x + x;
			const newy &#x3D; this.activeLayerMouseOffset.y + y;
			
			if(!this.canMoveActiveLayer(newx, newy)){
				this.draggingActiveLayer &#x3D; false;
				this.draw();
				return;
			}
			
			if(this.fireEvent(&#x27;layer-drag&#x27;)){
				
				var moveRightPixels &#x3D; newx - this.activeLayer.x;
				var moveDownPixels &#x3D; newy - this.activeLayer.y;
				
				this.activeLayer.x +&#x3D; moveRightPixels;
				this.activeLayer.y +&#x3D; moveDownPixels;
				
				if(this.activeLayer instanceof CanvasLayerGroup){
					this.activeLayer.updateLayers();
				}
				
				this.draw();
			}
		}else if(this.resizingActiveLayer){
			
			const {width, height} &#x3D; this.calculateLayerResize(x, y);
			if(!this.canResizeActiveLayer(width, height)){
				this.draggingActiveLayer &#x3D; false;
				this.draw();
				return;
			}
			
			if(this.fireEvent(&#x27;layer-resize&#x27;)){
				this.activeLayer.width &#x3D; width;
				this.activeLayer.height &#x3D; height;
				
				if(this.activeLayer instanceof CanvasLayerGroup){
					this.activeLayer.updateLayers();
				}
				
				this.draw();
			}
		}
	}
	
	/**
	 * Set the appropriate cursor.
	 * @ignore
	 */
	setCursor(x, y){
		if(this.rotatingActiveLayer){
			document.body.style.cursor &#x3D; this.cursors.rotating;
		}else if(this.draggingActiveLayer){
			document.body.style.cursor &#x3D; this.cursors.grabbing;
		}else if(this.resizingActiveLayer){
			document.body.style.cursor &#x3D; this.cursors.move;
		}else if(this.isNearActiveCorner(x, y)){
			document.body.style.cursor &#x3D; this.cursors.move;
		}else if(this.isNearActiveRotatePoint(x, y)){
			document.body.style.cursor &#x3D; this.cursors.rotate;
		}else if(this.isOverSelectableLayer(x, y)){
			document.body.style.cursor &#x3D; this.cursors.grab;
		}else{
			document.body.style.cursor &#x3D; this.cursors.default;
		}
	}
	
	/**
	 * Calculate new width and height of resizing image
	 * @ignore
	 */
	calculateLayerResize(x, y){
		var width &#x3D; this.activeLayer.width;
		var height &#x3D; this.activeLayer.height;
		
		var o &#x3D; this.lastMouseDownOffset;
		var n &#x3D; Canvas.layerRelativePoint(x, y, this.activeLayer);
		if(o.x &gt; 0){
			width &#x3D; Math.abs(this.activeLayerOriginalDimensions.width - (o.x-n.x)*2);
		}else{
			width &#x3D; Math.abs(this.activeLayerOriginalDimensions.width - (n.x-o.x)*2);
		}
		if(o.y &gt; 0){
			height &#x3D; Math.abs(this.activeLayerOriginalDimensions.height - (o.y-n.y)*2);
		}else{
			height &#x3D; Math.abs(this.activeLayerOriginalDimensions.height - (n.y-o.y)*2);
		}
		if(this.shiftKeyDown){
			var ratio &#x3D; Math.min(
				width/this.activeLayerOriginalDimensions.width, 
				height/this.activeLayerOriginalDimensions.height
			);
			width &#x3D; this.activeLayerOriginalDimensions.width * ratio;
			height &#x3D; this.activeLayerOriginalDimensions.height * ratio;
		}
		
		return {width, height};
	}
	
	/**
	 * Fire an event.
	 * @ignore
	 */
	fireEvent(type){
		var event &#x3D; new CustomEvent(type, {detail: this, cancelable: true, bubbles: true});
		return this.canvas.dispatchEvent(event);
	}
	
	/**
	 * Listen for click event on a layer
	 * @ignore
	 */
	onclick(e){
		var {x, y} &#x3D; this.canvasMousePos(e);
		var lcl &#x3D; this.getLayerAt(x, y);
		if(lcl){
			this.last_clicked_layer &#x3D; lcl;
			this.fireEvent(&#x27;layer-click&#x27;);
		}
	}
	
	/**
	 * Listen for dbl click event on a layer
	 * @ignore
	 */
	ondblclick(e){
		var {x, y} &#x3D; this.canvasMousePos(e);
		var lcl &#x3D; this.getLayerAt(x, y);
		if(lcl){
			this.last_clicked_layer &#x3D; lcl;
			this.fireEvent(&#x27;layer-dblclick&#x27;);
		}
	}
	
	/**
	 * Handle mousedown over the canvas.
	 * @ignore
	 */
	async onmousedown(e){
		var {x, y} &#x3D; this.canvasMousePos(e);
		this.setCursor(x, y);
		if(this.isNearActiveRotatePoint(x, y)){
			if(this.fireEvent(&#x27;layer-rotate-start&#x27;)){
				this.activeLayerRotateStartPos &#x3D; {x, y};
				this.rotatingActiveLayer &#x3D; true;
			}
		}else if(this.isNearActiveCorner(x, y)){
			if(this.fireEvent(&#x27;layer-resize-start&#x27;)){
				this.resizingActiveLayer &#x3D; true;
			}
		}else{
			var cancelled &#x3D; false;
			var layer &#x3D; this.getLayerAt(x, y);
			if(layer !&#x3D;&#x3D; null &amp;amp;&amp;amp; layer.selectable &#x3D;&#x3D;&#x3D; false) layer &#x3D; null;
			if(layer !&#x3D;&#x3D; null &amp;amp;&amp;amp; this.activeLayer !&#x3D;&#x3D; null &amp;amp;&amp;amp; layer !&#x3D;&#x3D; this.activeLayer){
				cancelled &#x3D; !this.fireEvent(&#x27;layer-deselect&#x27;);
				if(!cancelled) !this.deSelectLayer();
			}
			if(!cancelled &amp;amp;&amp;amp; layer !&#x3D;&#x3D; null &amp;amp;&amp;amp; this.fireEvent(&#x27;layer-drag-start&#x27;)){
				this.activeLayerMouseOffset.x &#x3D; layer.x - x;
				this.activeLayerMouseOffset.y &#x3D; layer.y - y;
				if(layer.draggable) this.draggingActiveLayer &#x3D; true;
				if(layer !&#x3D;&#x3D; this.activeLayer){
					if(this.fireEvent(&#x27;layer-select&#x27;)){
						this.selectLayer(layer);
					}
				}
			}
		}
		if(this.activeLayer){
			this.activeLayerOriginalDimensions &#x3D; {
				width: this.activeLayer.width,
				height: this.activeLayer.height
			};
			this.lastMouseDownOffset &#x3D; Canvas.layerRelativePoint(x, y, this.activeLayer);
		}
		
		// Handling the grouping 
		var layer &#x3D; this.getLayerAt(x, y);
		if(layer &amp;amp;&amp;amp; layer !&#x3D;&#x3D; this.ctrlGroupLayer &amp;amp;&amp;amp; layer.selectable){
			if(!this.isCtrlPressed) this.destroyCtrlGroup();	
			if(!this.isLayerInGroup(layer)){
				this.muteStateChanges &#x3D; true;
				await this.ctrlGroupLayer.addLayer(layer);
				if(this.ctrlGroupLayer.layers.length &#x3D;&#x3D;&#x3D; 1) this.selectLayer(layer);
				layer.onload(()&#x3D;&gt;{
					this.muteStateChanges &#x3D; false;
				});
			}
			if(!this.isGroupOnCanvas() &amp;amp;&amp;amp; this.ctrlGroupLayer.layers.length &gt; 1){
				this.muteStateChanges &#x3D; true;
				this.ctrlGroupLayer.layers.forEach(l&#x3D;&gt;{
					this.removeLayer(l);
				});
				this.addLayer(this.ctrlGroupLayer);
				this.ctrlGroupLayer.onload(()&#x3D;&gt;{
					this.muteStateChanges &#x3D; false;
				});
			}
			if(this.isGroupOnCanvas()){
				this.selectLayer(this.ctrlGroupLayer);
			}
		}
		
	}
	
	/**
	 * Are teh given coordinates near an active rotate anchor.
	 * @ignore
	 */
	isNearActiveRotatePoint(x, y){
		if(!this.activeLayer || !this.activeLayer.rotateable) return false;
		var {x, y} &#x3D; Canvas.layerRelativePoint(x, y, this.activeLayer);
		var mx &#x3D; (this.activeLayer.width/2)+25;
		var my &#x3D; 0;
		var dist &#x3D; Math.hypot(mx-x, my-y);
		if(dist &amp;lt;&#x3D; this.getScale() * this.anchorRadius) return true;
		return false;
	}
	
	/**
	 * Are the given coordinates near an active resize anchor.
	 * @ignore
	 */
	isNearActiveCorner(x, y){
		if(!this.activeLayer || !this.activeLayer.resizable) return false;
		var {x, y} &#x3D; Canvas.layerRelativePoint(x, y, this.activeLayer);
		var isNear &#x3D; false;
		this.activeLayer.getCorners().forEach(corner&#x3D;&gt;{			
			var dist &#x3D; Math.hypot(corner.x-x, corner.y-y);
			if(dist &amp;lt;&#x3D; this.getScale() * this.anchorRadius) isNear &#x3D; true;
		});
		return isNear;
	}
	
	/**
	 * Given a position, check if it is in bounds
	 * @ignore
	 */
	isNewPosInBounds(layer, x, y, width, height){
		var _x &#x3D; layer.x;
		var _y &#x3D; layer.y;
		var _width &#x3D; layer.width;
		var _height &#x3D; layer.height;
		
		layer.x &#x3D; x;
		layer.y &#x3D; y;
		layer.width &#x3D; width;
		layer.height &#x3D; height;
		
		var inbounds &#x3D; true;
		layer.getCorners().forEach(corner &#x3D;&gt; {
			var pos &#x3D; Canvas.absolutePoint(corner.x, corner.y, layer.x, layer.y, layer.rotation);
			if (pos.x &amp;lt; 0 || pos.x &gt; this.width || pos.y &amp;lt; 0 || pos.y &gt; this.width) {
				inbounds &#x3D; false;
			}
		});
		layer.x &#x3D; _x;
		layer.y &#x3D; _y;
		layer.width &#x3D; _width;
		layer.height &#x3D; _height;
		return inbounds;
	}
	
	/**
	 * Get nearest grid line
	 * @ignore
	 */
	getNearestGridline(n, grid){
		return Object.values(grid.reduce((acc, val)&#x3D;&gt;{
			if(val &gt; n){
				if(null &#x3D;&#x3D;&#x3D; acc.high) acc.high &#x3D; val;
				else acc.high &#x3D; Math.min(acc.high, val);
			}else{
				if(null &#x3D;&#x3D;&#x3D; acc.low) acc.low &#x3D; val;
				else acc.low &#x3D; Math.max(acc.low, val);
			}
			return acc;
		}, {low: null, high: null})).reduce((acc, val)&#x3D;&gt;{
			var valDistToN &#x3D; Math.abs(val - n);
			var accDistToN &#x3D; acc &#x3D;&#x3D;&#x3D; null ? null : Math.abs(acc - n);
			if(acc &#x3D;&#x3D;&#x3D; null || valDistToN &amp;lt; accDistToN) acc &#x3D; val;
			return acc;
		}, null);
	}
	
	/**
	 * Handle mouseup or mouseout.
	 * @ignore
	 */
	onmousereset(e){
		if(this.draggingActiveLayer) this.fireEvent(&quot;layer-drag-end&quot;);
		if(this.resizingActiveLayer) this.fireEvent(&quot;layer-resize-end&quot;);
		if(this.rotatingActiveLayer) this.fireEvent(&quot;layer-rotate-end&quot;);
		
		if(this.draggingActiveLayer &amp;amp;&amp;amp; this.snapToGrid &amp;amp;&amp;amp; this.activeLayer){
			var {xs, ys} &#x3D; this.getGridLines();
			var closestx &#x3D; this.getNearestGridline(this.activeLayer.x, xs);
			var closesty &#x3D; this.getNearestGridline(this.activeLayer.y, ys);
			var redraw_required &#x3D; false;
			var dist &#x3D; Math.abs(closestx - this.activeLayer.x);
			if(dist &amp;lt;&#x3D; this.gridDistancePixels &amp;amp;&amp;amp; dist !&#x3D;&#x3D; 0){
				this.activeLayer.x &#x3D; closestx;
				redraw_required &#x3D; true;
			}
			dist &#x3D; Math.abs(closesty - this.activeLayer.y);
			if(dist &amp;lt;&#x3D; this.gridDistancePixels &amp;amp;&amp;amp; dist !&#x3D;&#x3D; 0){
				this.activeLayer.y &#x3D; closesty;
				redraw_required &#x3D; true;
			}
			if(redraw_required){
				this.draw();
			}
		}
		if(this.draggingActiveLayer || this.resizingActiveLayer || this.rotatingActiveLayer) this.saveState();
		var {x, y} &#x3D; this.canvasMousePos(e);
		this.draggingActiveLayer &#x3D; false;
		this.resizingActiveLayer &#x3D; false;
		this.rotatingActiveLayer &#x3D; false;
		this.lastMouseDownOffset &#x3D; {x:0, y:0};
		this.activeLayerMouseOffset &#x3D; {x:0, y:0};
		this.activeLayerOriginalDimensions &#x3D; {width:0, height:0};
		this.activeLayerRotateStartPos &#x3D; {x:0, y:0};
		this.setCursor(x, y);
	}
	
	/**
	 * Get the scale of the canvas
	 * @ignore
	 */
	getScale(){
		var rect &#x3D; this.canvas.getBoundingClientRect();
		return this.canvas.width / rect.width;
	}
	
}

/**
 * The version of the library
 * @type {String}
 */
Canvas.version &#x3D; &#x27;1.2.31&#x27;;

/**
 * The default anchorRadius value for all Canvas instances.
 * @type {Number}
 */
Canvas.anchorRadius &#x3D; 8;

/**
 * The default strokeStyle value for all Canvas instances.
 * @type {String}
 */
Canvas.strokeStyle &#x3D; &#x27;#ba0000&#x27;;

/**
 * The default fillStyle value for all Canvas instances.
 * @type {String}
 */
Canvas.fillStyle &#x3D; &#x27;black&#x27;;

/**
 * The default lineWidth value for all Canvas instances.
 * @type {Number}
 */
Canvas.lineWidth &#x3D; 5;

/**
 * The default Cursor values for all Canvas instances. See the canvas constructor for details.
 * @type {Object}
 * @property {String} Canvas.cursors.default
 * @property {String} Canvas.cursors.grab
 * @property {String} Canvas.cursors.grabbing
 * @property {String} Canvas.cursors.move
 * @property {String} Canvas.cursors.rotate
 * @property {String} Canvas.cursors.rotating
 */
Canvas.cursors &#x3D; {
	default: null,
	grab: &quot;grab&quot;,
	grabbing: &quot;grabbing&quot;,
	move: &quot;crosshair&quot;,
	rotate: &quot;grab&quot;,
	rotating: &quot;grabbing&quot;
};


/**
 * Convert a relative point to an absolute point.
 * @ignore
 */
Canvas.absolutePoint &#x3D; (relPointX, relPointY, centerX, centerY, rotationDegrees) &#x3D;&gt; {
   var radians &#x3D; rotationDegrees * (Math.PI / 180);
   var cos &#x3D; Math.cos(radians);
   var sin &#x3D; Math.sin(radians);
   var x &#x3D; centerX + (relPointX * cos) - (relPointY * sin);
   var y &#x3D; centerY + (relPointX * sin) + (relPointY * cos);
   return {x, y};
};

/**
 * Get the position of a point relative to another point and possibly rotated.
 * @ignore
 */
Canvas.relativePoint &#x3D; (absPointX, absPointY, centerX, centerY, rotation) &#x3D;&gt; {
   absPointX -&#x3D; centerX;
   absPointY -&#x3D; centerY;
   var radians &#x3D; rotation * (Math.PI / 180);
   var cos &#x3D; Math.cos(radians);
   var sin &#x3D; Math.sin(radians);
   var x &#x3D; (absPointX * cos) + (absPointY * sin);
   var y &#x3D; (-absPointX * sin) + (absPointY * cos);
   x &#x3D; Math.floor(x * 100) / 100;
   y &#x3D; Math.floor(y * 100) / 100;
   return {x, y};
};

/**
 * Get the point relative to the center of a given layer.
 * @ignore
 */
Canvas.layerRelativePoint &#x3D; (absPointX, absPointY, layer) &#x3D;&gt; {
   return Canvas.relativePoint(absPointX, absPointY, layer.x, layer.y, layer.rotation);
};

/**
 * Are the given coordinates over the given layer?
 * @param {Number} x - The x ordinate.
 * @param {Number} y - The y ordinate.
 * @param {CanvasLayer} layer - The layer to check.
 * @returns {Boolean}
 */
Canvas.isOverLayer &#x3D; (x, y, layer) &#x3D;&gt; {
	let r &#x3D; Canvas.layerRelativePoint(x, y, layer);
	if(r.x &gt; (layer.width/2)) return false;
	if(r.x &amp;lt; -(layer.width/2)) return false;
	if(r.y &gt; (layer.height/2)) return false;
	if(r.y &amp;lt; -(layer.height/2)) return false;
	return true;
};

/**
 * returns true if the line from (a,b)-&gt;(c,d) intersects with (p,q)-&gt;(r,s)
 * @url https://stackoverflow.com/questions/9043805/test-if-two-lines-intersect-javascript-function
 * @returns {Boolean}
 */
Canvas.doLinesIntersect &#x3D; (a,b,c,d,p,q,r,s) &#x3D;&gt; {
	var det, gamma, lambda;
	det &#x3D; (c - a) * (s - q) - (r - p) * (d - b);
	if (det &#x3D;&#x3D;&#x3D; 0) {
		return false;
	} else {
		lambda &#x3D; ((s - q) * (r - a) + (p - r) * (s - b)) / det;
		gamma &#x3D; ((b - d) * (r - a) + (c - a) * (s - b)) / det;
		return (0 &amp;lt; lambda &amp;amp;&amp;amp; lambda &amp;lt; 1) &amp;amp;&amp;amp; (0 &amp;lt; gamma &amp;amp;&amp;amp; gamma &amp;lt; 1);
	}
};

/**
 * Class representing the layers drawn on the canvas.
 */
class CanvasLayer{
	
	/**
	 * Create a new Layer.
	 * @param {String} url - The URL or URI of an image to draw on the canvas.
	 * @param {String} name - The name of the layer.
	 * @param {Number} x - The x position of the layer on the canvas.
	 * @param {Number} y - The y position of the layer on the canvas.
	 * @param {Number} [width&#x3D;null] - The width of the layer on the canvas.
	 * @param {Number} [height&#x3D;null] - The height of the layer on the canvas.
	 * @param {Number} [rotation&#x3D;0] - The rotation of the layer on the canvas.
	 * @param {Boolean} [draggable&#x3D;true] - Is the layer draggable?
	 * @param {Boolean} [rotateable&#x3D;true] - Is the layer rotateable?
	 * @param {Boolean} [resizable&#x3D;true] - Is the layer resizable?
	 * @param {Boolean} [selectable&#x3D;true] - Is the layer selectable?
	 * @param {Boolean} [forceBoundary&#x3D;false] - Force the layer to stay in bounds?
	 * @param {Boolean} [opts.allowOverlap&#x3D;true] - Allow layers to overlap with this one.
	 * @returns {CanvasLayer}
	 */
	constructor(url, name, x, y, width&#x3D;null, height&#x3D;null, rotation&#x3D;0, draggable&#x3D;true, rotateable&#x3D;true, resizable&#x3D;true, selectable&#x3D;true, forceBoundary&#x3D;false, allowOverlap&#x3D;true){
		this.name &#x3D; name;
		this.url &#x3D; url;
		this.ready &#x3D; false;
		this.image &#x3D; null;
		this.x &#x3D; x;
		this.y &#x3D; y;
		this.width &#x3D; width;
		this.height &#x3D; height;
		this.rotation &#x3D; rotation;
		this.draggable &#x3D; draggable;
		this.rotateable &#x3D; rotateable;
		this.resizable &#x3D; resizable;
		this.selectable &#x3D; selectable;
		this.forceBoundary &#x3D; forceBoundary;
		this.allowOverlap &#x3D; allowOverlap;
		this.load_cb_stack &#x3D; [];
		
		this.xoffset &#x3D; 0;
		this.yoffset &#x3D; 0;
		this.roffset &#x3D; 0;
		this.owidth &#x3D; 0;
		this.oheight &#x3D; 0;
		
		this.load();
	}
	
	/**
	 * jsonify the current layer
	 * @returns {String} - Serialized layer
	 */
	objectify(){
		return {
			layer: this, 
			state: {
				name: this.name,
				url: this.url,
				x: this.x,
				y: this.y,
				width: this.width,
				height: this.height,
				rotation: this.rotation,
				draggable: this.draggable,
				rotatable: this.rotateable,
				resizable: this.resizable,
				selectable: this.selectable,
				forceBoundary: this.forceBoundary
			}
		};
	}
	
	/**
	 * Register a function to be called when the layer is fully loaded.
	 * @param {Function} fn - The callback function.
	 * @returns {undefined}
	 */
	onload(fn){
		if(this.ready){
			fn();
			return;
		}else{
			this.load_cb_stack.push(fn);
		}
	}
	
	/**
	 * Load the layer so it is ready to use.
	 * @returns {Promise} - A promise that resolves when the layer is ready
	 */
	load(){
		return new Promise(done&#x3D;&gt;{
			if(this.ready){
				done();
			}else{
				const img &#x3D; new Image();
				img.onload &#x3D; ()&#x3D;&gt;{
					this.image &#x3D; img;
					if(this.width&#x3D;&#x3D;&#x3D;null) this.width &#x3D; img.width;
					if(this.height&#x3D;&#x3D;&#x3D;null) this.height &#x3D; img.height;
					this.ready &#x3D; true;
					this.load_cb_stack.forEach(fn&#x3D;&gt;fn());
					this.load_cb_stack &#x3D; [];
					done();
				};
				img.src &#x3D; this.url;
			}
		});
	}
	
	/**
	 * Get the relative position of all the corners.
	 * @ignore
	 */
	getCorners(){
		return [
			{x:-(this.width/2), y:-(this.height/2)},
			{x:-(this.width/2)+this.width, y:-(this.height/2)},
			{x:-(this.width/2)+this.width, y:-(this.height/2)+this.height},
			{x:-(this.width/2), y:-(this.height/2)+this.height}
		];
	}
	
}

/**
 * un Serialize a layer
 * @param {type} str
 * @returns {CanvasLayer}
 */
CanvasLayer.deobjectify &#x3D; function(d){
	var layer &#x3D; d.layer;
	Object.keys(d.state).forEach(key&#x3D;&gt;{
		layer[key] &#x3D; d.state[key];
	});
	return layer;
};

/**
 * CavnasLayer that controls multiple layers
 */
class CanvasLayerGroup extends CanvasLayer{
	
	/**
	 * Create a new Layer.
	 * @param {String} name - The name of the layer.
	 * @param {Boolean} [draggable&#x3D;true] - Is the layer draggable?
	 * @param {Boolean} [rotateable&#x3D;true] - Is the layer rotateable?
	 * @param {Boolean} [resizable&#x3D;true] - Is the layer resizable?
	 * @param {Boolean} [selectable&#x3D;true] - Is the layer selectable?
	 * @param {Boolean} [forceBoundary&#x3D;false] - Force the layer to stay in bounds?
	 * @returns {CanvasLayerGroup}
	 */
	constructor(name, draggable&#x3D;true, rotateable&#x3D;true, resizable&#x3D;true, selectable&#x3D;true, forceBoundary&#x3D;false){
		var url &#x3D; &#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/1+yHgAHtAKYD9BncgAAAABJRU5ErkJggg&#x3D;&#x3D;&#x27;;
		super(url, name, 0, 0, 1, 1, 0, draggable, rotateable, resizable, selectable, forceBoundary);
		this.layers &#x3D; [];
	}
	
	/**
	 * Get the layer on the given canvas at the given position. If this group 
	 * is selected it will return the layer in this group at the given 
	 * position, if applicatble.
	 * @param {Canvas} canvas - The Canvas element that owns the layers.
	 * @param {Number} x - The x position of the mouseclick relative to the canvas.
	 * @param {Number} y - The y position of the mouseclick relative to the canvas.
	 * @returns {layer|null}
	 */
	getLayerOrSubLayerAt(canvas, x, y){
		for(let i&#x3D;0; i&amp;lt;canvas.layers.length; i++){
			
			let layer &#x3D; canvas.layers[i];
			
			if(layer &#x3D;&#x3D;&#x3D; this){
				for(let i&#x3D;this.layers.length; i--;){
					let layer &#x3D; this.layers[i];
					if(Canvas.isOverLayer(x, y, layer)) return layer;
				}
			}
			
			if(Canvas.isOverLayer(x, y, layer)) return layer;
		}
		return null;
	}
	
	/**
	 * Remove the provided layer from the group.
	 * @param {CanvasLayer} layer - The layer to remove.
	 * @returns {Promise}
	 */
	async removeLayer(layer){
		delete layer.xoffset;
		delete layer.yoffset;
		this.layers.splice(this.layers.indexOf(layer), 1);
		return await this.regenerate();
	}
	
	/**
	 * Add a layer to the group
	 * @param {CanvasLayer} layer - The layer to add.
	 * @returns {Promise}
	 */
	async addLayer(layer){
		if(layer &#x3D;&#x3D;&#x3D; this) return;
		if(layer instanceof CanvasLayerGroup){
			this.layers.push(...layer.layers);
		}else{			
			this.layers.push(layer);
		}
		return await this.regenerate();
	}
	
	/**
	 * Regenerate images and dimensions.
	 * @ignore
	 */
	async regenerate(){
		var params &#x3D; await this.getParams();
		
		this.width &#x3D; this.owidth &#x3D; params.width;
		this.height &#x3D; this.oheight &#x3D; params.height;
		
		this.x &#x3D; params.x;
		this.y &#x3D; params.y;
		this.rotation &#x3D; 0;
		
		this.forceBoundary &#x3D; params.forceBoundary;
		this.draggable &#x3D;  params.draggable;
		this.rotateable &#x3D;  params.rotateable;
		this.resizable &#x3D;  params.resizable;
		this.selectable &#x3D; params.selectable;
		
		this.url &#x3D; params.uri;
		this.ready &#x3D; false;
		return await this.load();
	}
	
	/**
	 * Update the sublayers of this group.
	 * @ignore
	 */
	updateLayers(){
		var ratiox &#x3D; this.width/this.owidth;
		var ratioy &#x3D; this.height/this.oheight;
		this.layers.forEach(layer&#x3D;&gt;{
			layer.width &#x3D; layer.owidth * ratiox;
			layer.height &#x3D; layer.oheight * ratioy;			
			layer.rotation &#x3D; layer.roffset + this.rotation;
			var pos &#x3D; Canvas.absolutePoint(layer.xoffset*ratiox, layer.yoffset*ratioy, this.x, this.y, this.rotation);
			layer.x &#x3D; pos.x;
			layer.y &#x3D; pos.y;
			
		});
	}
	
	/**
	 * Regenerate images and dimensions.
	 * @ignore
	 */
	async getParams(){
		const allCorners &#x3D; this.layers.map(layer &#x3D;&gt; {
			return layer.getCorners().map(corner&#x3D;&gt;{
				return Canvas.absolutePoint(corner.x, corner.y, layer.x, layer.y, layer.rotation);
			});
		});
		
		const allBounds &#x3D; [];
		allCorners.forEach(corners&#x3D;&gt;{
			allBounds.push(...corners);
		});

		var pos &#x3D; {
			left: allBounds.reduce((acc, cur)&#x3D;&gt;Math.min(acc, cur.x), Infinity),
			top: allBounds.reduce((acc, cur)&#x3D;&gt;Math.min(acc, cur.y), Infinity),
			right: allBounds.reduce((acc, cur)&#x3D;&gt;Math.max(acc, cur.x),0),
			bottom: allBounds.reduce((acc, cur)&#x3D;&gt;Math.max(acc, cur.y),0)
		};
		pos.width &#x3D; pos.right - pos.left;
		pos.height &#x3D; pos.bottom - pos.top;
		pos.x &#x3D; pos.left+(pos.width/2);
		pos.y &#x3D; pos.top+(pos.height/2);

		var ele &#x3D; document.createElement(&#x27;canvas&#x27;);
		ele.width &#x3D; pos.right+2;
		ele.height &#x3D; pos.bottom+2;
		var canvas &#x3D; new Canvas(ele);
		this.layers.forEach(layer&#x3D;&gt;canvas.addLayer(layer));
		
		pos.uri &#x3D; await canvas.extractPortion(pos.x, pos.y, pos.width, pos.height, 0, false);
		
		pos.forceBoundary &#x3D; this.layers.reduce((acc, itm)&#x3D;&gt;itm.forceBoundary||acc,false);
		pos.draggable &#x3D; this.layers.reduce((acc, itm)&#x3D;&gt;acc&#x3D;&#x3D;&#x3D;false?false:itm.draggable,true);
		pos.rotateable &#x3D; this.layers.reduce((acc, itm)&#x3D;&gt;acc&#x3D;&#x3D;&#x3D;false?false:itm.draggable,true);
		pos.resizable &#x3D; this.layers.reduce((acc, itm)&#x3D;&gt;acc&#x3D;&#x3D;&#x3D;false?false:itm.draggable,true);
		pos.selectable &#x3D; this.layers.reduce((acc, itm)&#x3D;&gt;acc&#x3D;&#x3D;&#x3D;false?false:itm.draggable,true);
		
		this.layers.forEach(l&#x3D;&gt;{
			l.xoffset &#x3D; l.x - pos.x;
			l.yoffset &#x3D; l.y - pos.y;
			l.roffset &#x3D; l.rotation;
			l.owidth &#x3D; l.width;
			l.oheight &#x3D; l.height;
		});
		
		return pos;
	}

}</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 3.6.2 on October 29, 2019.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/jquery.cookie.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>