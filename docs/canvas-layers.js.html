<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 3.6.2">
  <meta charset="utf-8">
  <title>Source: canvas-layers.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: canvas-layers.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>/**
 * canvas-layers - v1.1.61
 * Allow user to position and re-arrange images on a canvas.
 * @author Pamblam
 * @website 
 * @license MIT
 */


/**
 * Interface for handling all canvas functionality
 * @see https://pamblam.github.io/canvas-layers/examples/
 * @version 1.1.61
 */
class Canvas{
	
	/**
	 * Construct a new instance of the Canvas class
	 * @param {HTMLElement} canvas - The canvas to instantiate the class upon.
	 * @param {Number} [opts.anchorRadius&#x3D;Canvas.anchorRadius] - The radius of the anchor points shown on selected elements.
	 * @param {String} [opts.strokeStyle&#x3D;Canvas.strokeStyle] - The color of the outlines drawn on selceted elements. May be any valid CSS color string.
	 * @param {String} [opts.fillStyle&#x3D;Canvas.fillStyle] - The color of the anchor points shown on selected elements. May be any valid CSS color string.
	 * @param {Number} [opts.lineWidth&#x3D;Canvas.lineWidth] - The width of the outlines shown on selected elements.
	 * @param {String} [opts.cursors.default&#x3D;Canvas.cursors.default] - The default cursor to use when hovering over the canvas. May be any valid css cursor value.
	 * @param {String} [opts.cursors.grab&#x3D;Canvas.cursors.grab] - The grab cursor to use when hovering over a movable layer. May be any valid css cursor value.
	 * @param {String} [opts.cursors.grabbing&#x3D;Canvas.cursors.grabbing] - The grabbing cursor to use when dragging a layer. May be any valid css cursor value.
	 * @param {String} [opts.cursors.move&#x3D;Canvas.cursors.move] - The default cursor to use when hovering over a resize anchor. May be any valid css cursor value.
	 * @param {String} [opts.cursors.rotate&#x3D;Canvas.cursors.rotate] - The default cursor to use when hovering a rotate anchor point. May be any valid css cursor value.
	 * @param {String} [opts.cursors.rotating&#x3D;Canvas.cursors.rotating] - The default cursor to use when rotating an active layer. May be any valid css cursor value.
	 * @returns {Canvas}
	 */
	constructor(canvas, opts&#x3D;{}){
		this.canvas &#x3D; canvas;
		this.width &#x3D; canvas.width;
		this.height &#x3D; canvas.height;
		this.ctx &#x3D; canvas.getContext(&#x27;2d&#x27;);
		this.layers &#x3D; [];
		this.layer_state_pos &#x3D; -1;
		this.layer_states &#x3D; [];
		this.activeLayer &#x3D; null;
		this.shiftKeyDown &#x3D; false;
		this.draggingActiveLayer &#x3D; false;
		this.resizingActiveLayer &#x3D; false;
		this.rotatingActiveLayer &#x3D; false;
		this.lastMouseDownOffset &#x3D; {x:0, y:0};
		this.activeLayerMouseOffset &#x3D; {x:0, y:0};
		this.activeLayerOriginalDimensions &#x3D; {width:0, height:0};
		this.activeLayerRotateStartPos &#x3D; {x:0, y:0};
		this.displayGrid &#x3D; false;
		this.snapToGrid &#x3D; false;
		this.gridDistancePixels &#x3D; 10;
		canvas.addEventListener(&#x27;mousemove&#x27;, this.onmousemove.bind(this));
		canvas.addEventListener(&#x27;mousedown&#x27;, this.onmousedown.bind(this));
		canvas.addEventListener(&#x27;mouseout&#x27;, this.onmousereset.bind(this));
		canvas.addEventListener(&#x27;mouseup&#x27;, this.onmousereset.bind(this));
		canvas.addEventListener(&#x27;click&#x27;, this.onclick.bind(this));
		canvas.addEventListener(&#x27;dblclick&#x27;, this.ondblclick.bind(this));
		document.addEventListener(&#x27;keydown&#x27;, this.onkeyevent.bind(this));
		document.addEventListener(&#x27;keyup&#x27;, this.onkeyevent.bind(this));
		
		this.anchorRadius &#x3D; opts.anchorRadius || Canvas.anchorRadius;
		this.strokeStyle &#x3D; opts.strokeStyle || Canvas.strokeStyle;
		this.fillStyle &#x3D; opts.fillStyle || Canvas.fillStyle;
		this.lineWidth &#x3D; opts.lineWidth || Canvas.lineWidth;
		this.cursors &#x3D; opts.cursors || {};
		this.cursors.default &#x3D; this.cursors.default || Canvas.cursors.default;
		this.cursors.grab &#x3D; this.cursors.grab || Canvas.cursors.grab;
		this.cursors.grabbing &#x3D; this.cursors.grabbing || Canvas.cursors.grabbing;
		this.cursors.move &#x3D; this.cursors.move || Canvas.cursors.move;
		this.cursors.rotate &#x3D; this.cursors.rotate || Canvas.cursors.rotate;
		this.cursors.rotating &#x3D; this.cursors.rotating || Canvas.cursors.rotating;
		this.last_clicked_layer &#x3D; null;
		this.pending_layers &#x3D; 0;
		this.ready &#x3D; true;
	}	
	
	/**
	 * Load the state object
	 * @param {type} state
	 * @returns {undefined}
	 */
	loadState(state){
		this.layers &#x3D; state.map(s&#x3D;&gt;CanvasLayer.deobjectify(s));
		this.draggingActiveLayer &#x3D; false;
		this.resizingActiveLayer &#x3D; false;
		this.rotatingActiveLayer &#x3D; false;
		this.lastMouseDownOffset &#x3D; {x:0, y:0};
		this.activeLayerMouseOffset &#x3D; {x:0, y:0};
		this.activeLayerOriginalDimensions &#x3D; {width:0, height:0};
		this.activeLayerRotateStartPos &#x3D; {x:0, y:0};
		this.draw();
	}
	
	/**
	 * saves the current state in the state stack
	 * @returns {undefined}
	 */
	saveState(){
		var state &#x3D; this.layers.map(l&#x3D;&gt;l.objectify());
		this.layer_states.length &#x3D; this.layer_state_pos+1;
		this.layer_states.push(state);
		this.layer_state_pos &#x3D; this.layer_states.length-1;
	}
	
	/**
	 * Undo an action
	 * @returns {undefined}
	 */
	undo(){
		if(this.layer_state_pos&gt;0){
			this.layer_state_pos--;
			this.loadState(this.layer_states[this.layer_state_pos]);
		}
	}
	
	/**
	 * Redo the last un-did action
	 * @returns {undefined}
	 */
	redo(){
		if((this.layer_state_pos+1)&amp;lt;this.layer_states.length){
			this.layer_state_pos++;
			this.loadState(this.layer_states[this.layer_state_pos]);
		}
	}
	
	/**
	 * Enable snap to grid
	 * @returns {undefined}
	 */
	snapOn(gridDistancePixels&#x3D;10){
		this.snapToGrid &#x3D; true;
		gridDistancePixels &#x3D; +gridDistancePixels &amp;lt; 3 ? 3 : +gridDistancePixels;
		this.gridDistancePixels &#x3D; gridDistancePixels;
	}
	
	/**
	 * Disable snap to grid
	 * @returns {undefined}
	 */
	snapOff(){
		this.snapToGrid &#x3D; false;
		this.draw();
	}
	
	/**
	 * Show the grid lines on the canvas
	 * @returns {undefined}
	 */
	showGrid(gridDistancePixels&#x3D;10){
		this.displayGrid &#x3D; true;
		gridDistancePixels &#x3D; +gridDistancePixels &amp;lt; 3 ? 3 : +gridDistancePixels;
		this.gridDistancePixels &#x3D; gridDistancePixels;
		this.draw();
	}
	
	/**
	 * Hide the grid lines on the canvas
	 * @returns {undefined}
	 */
	hideGrid(){
		this.displayGrid &#x3D; false;
		this.draw();
	}
	
	/**
	 * Get a layer by it&#x27;s given name.
	 * @param {String} name - The name of the layer. 
	 * @returns {CanvasLayer|null}
	 */
	getLayerByName(name){
		for(var i&#x3D;this.layers.length; i--;){
			if(this.layers[i].name &#x3D;&#x3D;&#x3D; name) return this.layers[i];
		}
		return null;
	}
	
	/**
	 * Add a layer to the canvas.
	 * @param {String} url - The URI or URL of an image to draw on the canvas.
	 * @param {String} [opts.name&#x3D;&quot;Layer n&quot;] - The name of the layer.
	 * @param {Number} [opts.x&#x3D;this.width/2] - The x position of the layer.
	 * @param {Number} [opts.y&#x3D;this.height/2] - The y position of the layer.
	 * @param {Number} [opts.rotation&#x3D;0] - The rotation of the layer, counter-clockwise, in degrees.
	 * @param {Boolean} [opts.draggable&#x3D;true] - Can the user move this layer?
	 * @param {Boolean} [opts.rotateable&#x3D;true] - Can the user rotate this layer?
	 * @param {Boolean} [opts.resizable&#x3D;true] - Can the user resize this layer?
	 * @param {Boolean} [opts.selectable&#x3D;true] - Can the user select this layer?
	 * @param {Number} [opts.width&#x3D;null] - The width of the layer to be drawn. If not specified, defaults to the images natural width.
	 * @param {Number} [opts.height&#x3D;null] - The height of the layer to be drawn. If not specified, defaults to the images natural height.
	 * @param {Boolean} [opts.forceBoundary&#x3D;false] - Force the item to stay in bounds.
	 * @returns {CanvasLayer} - The layer that was added.
	 */
	addLayer(url, opts&#x3D;{}){
		this.ready &#x3D; false;
		const name &#x3D; opts.name || &#x60;Layer ${this.layers.length}&#x60;;
		const x &#x3D; parseFloat(opts.x || this.width/2);
		const y &#x3D; parseFloat(opts.y || this.height/2);
		const rotation &#x3D; parseFloat(opts.rotation || 0);
		const draggable &#x3D; opts.draggable &#x3D;&#x3D;&#x3D; undefined ? true : opts.draggable;
		const rotateable &#x3D; !!opts.rotateable &#x3D;&#x3D;&#x3D; undefined ? true : opts.rotateable;
		const resizable &#x3D; !!opts.resizable &#x3D;&#x3D;&#x3D; undefined ? true : opts.resizable;
		const selectable &#x3D; !!opts.selectable &#x3D;&#x3D;&#x3D; undefined ? true : opts.selectable;
		const width &#x3D; opts.width || null;
		const height &#x3D; opts.height || null;
		const forceBoundary &#x3D; opts.forceBoundary || false;
		var layer &#x3D; new CanvasLayer(url, name, x, y, width, height, rotation, draggable, rotateable, resizable, selectable, forceBoundary);
		this.layers.unshift(layer);
		this.pending_layers++;
		layer.onload(()&#x3D;&gt;{
			this.pending_layers--;
			if(0 &#x3D;&#x3D;&#x3D; this.pending_layers){
				this.ready &#x3D; true;
				this.draw();
				this.saveState();
			}
		});
		return layer;
	}
	
	/**
	 * Rotate and crop the canvas to the dimensions and rotation of the specified layer.
	 * @param {CanvasLayer} layer - The layer to crop to.
	 * @returns {Promise} - A Promise htat resolves with the DataURI of the cropped area.
	 */
	cropToLayer(layer){
		return this.extractPortion(layer.x, layer.y, layer.width, layer.height, layer.rotation);
	}
	
	/**
	 * Rotate and extract a custom area of the canvas.
	 * @param {Number} centerx - The x position of the center of the area to extract.
	 * @param {Number} centery - The y position of the center of the area to extract.
	 * @param {Number} width - The width of the area to extract from teh canvas.
	 * @param {Number} height - The height of the area to extract from teh canvas.
	 * @param {Number} [rotation&#x3D;0] - The rotation of the area to extract, counter-clockwise, in degrees.
	 * @returns {Promise} - A Promise htat resolves with the DataURI of the cropped area.
	 */
	extractPortion(centerx, centery, width, height, rotation&#x3D;0){
		var radians &#x3D; rotation * Math.PI / 180;
		var {x, y} &#x3D; this.absolutePoint(-(width/2), -(height/2), centerx, centery, rotation);
		
		var rectBB &#x3D; this.getRotatedRectBB(x, y, width, height, radians);
		
		var canvas0 &#x3D; document.createElement(&quot;canvas&quot;);
		var ctx0 &#x3D; canvas0.getContext(&quot;2d&quot;);
		var canvas1 &#x3D; document.createElement(&quot;canvas&quot;);
		var ctx1 &#x3D; canvas1.getContext(&quot;2d&quot;);
		var canvas2 &#x3D; document.createElement(&quot;canvas&quot;);
		var ctx2 &#x3D; canvas2.getContext(&quot;2d&quot;);
		
		canvas1.width &#x3D; canvas2.width &#x3D; rectBB.width;
		canvas1.height &#x3D; canvas2.height &#x3D; rectBB.height;
		canvas0.width &#x3D; this.width;
		canvas0.height &#x3D; this.height;
		
		return new Promise(done&#x3D;&gt;{
			this.loadAll().then(()&#x3D;&gt;{
				for(let i&#x3D;this.layers.length; i--;){
					let layer &#x3D; this.layers[i];
					var radians &#x3D; layer.rotation * (Math.PI/180);
					ctx0.translate(layer.x, layer.y);
					ctx0.rotate(radians);
					ctx0.drawImage(layer.image, -(layer.width/2), -(layer.height/2), layer.width, layer.height);
					ctx0.rotate(-radians);
					ctx0.translate(-layer.x, -layer.y);
				}

				ctx1.drawImage(canvas0, rectBB.cx - rectBB.width / 2, rectBB.cy - rectBB.height / 2, rectBB.width, rectBB.height, 0, 0, rectBB.width, rectBB.height);
				ctx2.translate(canvas1.width / 2, canvas1.height / 2);
				ctx2.rotate(-radians);
				ctx2.drawImage(canvas1, -canvas1.width / 2, -canvas1.height / 2);
				var ofstx &#x3D; (canvas2.width - width) / 2;
				var ofsty &#x3D; (canvas2.height - height) / 2;
				ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
				canvas1.width &#x3D; width;
				canvas1.height &#x3D; height;
				ctx1.drawImage(canvas2, -ofstx, -ofsty);
				done(canvas1.toDataURL());

			});
		});
	}
	
	/**
	 * Draw the canvas.
	 * @returns {undefined}
	 */
	draw(){
		if(!this.ready) return;
			
		this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
		for(let i&#x3D;this.layers.length; i--;){
			let layer &#x3D; this.layers[i];
			var radians &#x3D; layer.rotation * (Math.PI/180);
			this.ctx.translate(layer.x, layer.y);
			this.ctx.rotate(radians);
			
			this.ctx.drawImage(layer.image, -(layer.width/2), -(layer.height/2), layer.width, layer.height);
			
			if(layer &#x3D;&#x3D;&#x3D; this.activeLayer){
				this.ctx.strokeStyle &#x3D; this.strokeStyle;
				this.ctx.fillStyle &#x3D; this.fillStyle;
				this.ctx.lineWidth &#x3D; this.getScale() * this.lineWidth;
				this.ctx.strokeRect(-(layer.width/2), -(layer.height/2), layer.width, layer.height);
				if(layer.resizable){
					layer.getCorners().forEach(corner&#x3D;&gt;{
						this.drawCircle(corner.x, corner.y, this.getScale() * this.anchorRadius);
					});
				}
				if(layer.rotateable){
					this.ctx.beginPath();
					this.ctx.moveTo(0, 0);
					this.ctx.lineTo((layer.width/2)+25, 0);
					this.ctx.stroke();
					this.drawCircle((layer.width/2)+25, 0, this.getScale() * this.anchorRadius);
				}
			}
			this.ctx.rotate(-radians);
			this.ctx.translate(-layer.x, -layer.y);
		}
		
		if(this.displayGrid){
			this.ctx.strokeStyle &#x3D; &quot;rgba(0,0,0,0.2)&quot;;
			this.ctx.lineWidth &#x3D; this.getScale() * 2;
			var {xs, ys} &#x3D; this.getGridLines(false);
			xs.forEach(x&#x3D;&gt;{
				this.ctx.beginPath();
				this.ctx.moveTo(x, 0);
				this.ctx.lineTo(x, this.canvas.height);
				this.ctx.stroke(); 
			});
			ys.forEach(y&#x3D;&gt;{
				this.ctx.beginPath();
				this.ctx.moveTo(0, y);
				this.ctx.lineTo(this.canvas.width, y);
				this.ctx.stroke(); 
			});
		}
	}	
	
	/**
	 * Remove all layers from teh canvas.
	 * @returns {undefined}
	 */
	removeAllLayers(){
		this.deSelectLayer();
		this.layers &#x3D; [];
		this.draw();
	}
	
	/**
	 * Remove the specified layer from the canvas.
	 * @param {CanvasLayer} layer - The layer to remove
	 * @returns {undefined}
	 */
	removeLayer(layer){
		if(layer &#x3D;&#x3D;&#x3D; this.activeLayer) this.deSelectLayer();
		this.layers.splice(this.layers.indexOf(layer), 1);
		this.draw();
	}
	
	/**
	 * Select the given layer.
	 * @param {CanvasLayer} layer - The layer to select.
	 * @returns {undefined}
	 */
	selectLayer(layer){
		this.layers.unshift(this.layers.splice(this.layers.indexOf(layer), 1)[0]);
		this.activeLayer &#x3D; layer;
		this.draw();
	}
	
	/**
	 * Deselect the selected layer if one is selected.
	 * @returns {undefined}
	 */
	deSelectLayer(){
		this.activeLayer &#x3D; null;
		this.draggingActiveLayer &#x3D; false;
		this.draw();
	}
	
	/**
	 * Get the cooresponding coordinates of the mouses position on the canvas.
	 * @param {MouseEvent} e - The event passed to a mouse event handler.
	 * @returns {{x: Number, y: Number}}
	 */
	canvasMousePos(e) {
		var rect &#x3D; this.canvas.getBoundingClientRect();
		var x &#x3D; e.clientX - rect.left;
		var y &#x3D; e.clientY - rect.top;
		var wfactor &#x3D; this.canvas.width / rect.width;
		var hfactor &#x3D; this.canvas.height / rect.height;
		x &#x3D; x*wfactor;
		y &#x3D; y*hfactor;
		return {x, y};
	}
	
	/**
	 * Get the layer at the given canvas coordinates.
	 * @param {Number} x - The x ordinate.
	 * @param {Number} y - The y ordinate.
	 * @returns {CanvasLayer|null}
	 */
	getLayerAt(x, y){
		for(let i&#x3D;0; i&amp;lt;this.layers.length; i++){
			let layer &#x3D; this.layers[i];
			if(this.isOverLayer(x, y, layer)) return layer;
		}
		return null;
	}
	
	/**
	 * Are the given coordinates over a selectable layer?
	 * @param {Number} x - The x ordinate.
	 * @param {Number} y - The y ordinate.
	 * @returns {Boolean}
	 */
	isOverSelectableLayer(x, y){
		for(let i&#x3D;this.layers.length; i--;){
			if(this.isOverLayer(x, y, this.layers[i])){
				if(this.layers[i].selectable &amp;amp;&amp;amp; this.activeLayer !&#x3D;&#x3D; this.layers[i]) return true;
			}
		}
		return false;
	}
	
	/**
	 * Are the given coordinates over the given layer?
	 * @param {Number} x - The x ordinate.
	 * @param {Number} y - The y ordinate.
	 * @param {CanvasLayer} layer - The layer to check.
	 * @returns {Boolean}
	 */
	isOverLayer(x, y, layer){
		let r &#x3D; this.layerRelativePoint(x, y, layer);
		if(r.x &gt; (layer.width/2)) return false;
		if(r.x &amp;lt; -(layer.width/2)) return false;
		if(r.y &gt; (layer.height/2)) return false;
		if(r.y &amp;lt; -(layer.height/2)) return false;
		return true;
	}
	
	////////////////////////////////////////////////////////////////////////////
	// Undocumented utility layers /////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////
	
	/**
	 * Get an object containing arrays of x and y grid line positons
	 * @param {Boolean} snap - If true, get lines to snap to, else get lines to display
	 * @returns {Object} - An object with an &#x27;xs&#x27; property containing x positions and a &#x27;ys&#x27; property containing y positions;
	 */
	getGridLines(snap&#x3D;true){
		var xs &#x3D; [];
		var ys &#x3D; [];
		var dist &#x3D; 0;
		
		if(snap){
			dist &#x3D; this.gridDistancePixels;
		}else{
			dist &#x3D; this.gridDistancePixels * 2;
		}
		
		for(var x&#x3D;0; x&amp;lt;this.canvas.width; x +&#x3D; (this.getScale() * dist)){
			xs.push(x); 
		}
		for(var y&#x3D;0; y&amp;lt;this.canvas.height; y +&#x3D; (this.getScale() * dist)){
			ys.push(y);
		}
		for(let i&#x3D;this.layers.length; i--;){
			if(snap &amp;amp;&amp;amp; this.layers[i] &#x3D;&#x3D;&#x3D; this.activeLayer) continue;
			xs.push(this.layers[i].x);
			ys.push(this.layers[i].y);
		}
		[...new Set(xs)].sort();
		[...new Set(ys)].sort();
		return {xs, ys};
	}
	
	/**
	 * Load all layers.
	 * @ignore
	 */
	loadAll(){
		var promises &#x3D; this.layers.map(layer&#x3D;&gt;new Promise(done&#x3D;&gt;layer.onload(done)));
		return Promise.all(promises);
	}
	
	/**
	 * Get the bounding box of the defined area.
	 * @ignore
	 */
	getRotatedRectBB(x, y, width, height, rAngle) {
		var absCos &#x3D; Math.abs(Math.cos(rAngle));
		var absSin &#x3D; Math.abs(Math.sin(rAngle));
		var cx &#x3D; x + width / 2 * Math.cos(rAngle) - height / 2 * Math.sin(rAngle);
		var cy &#x3D; y + width / 2 * Math.sin(rAngle) + height / 2 * Math.cos(rAngle);
		var w &#x3D; width * absCos + height * absSin;
		var h &#x3D; width * absSin + height * absCos;
		return ({
			cx: cx,
			cy: cy,
			width: w,
			height: h
		});
	}
	
	/**
	 * Draw a circle on the canvas.
	 * @ignore
	 */
	drawCircle(x, y, radius){
		this.ctx.beginPath();
		this.ctx.arc(x, y, radius, 0, Math.PI*2, true); 
		this.ctx.closePath();
		this.ctx.fill();
	}
	
	/**
	 * Handle key down and keyup.
	 * @ignore
	 */
	onkeyevent(e){
		this.shiftKeyDown &#x3D; e.shiftKey;
	}
	
	/**
	 * Handle mouse moves over the canvas.
	 * @ignore
	 */
	onmousemove(e){
		var {x, y} &#x3D; this.canvasMousePos(e);
		this.setCursor(x, y);
		if(this.activeLayer &#x3D;&#x3D;&#x3D; null) return;
		
		if(this.rotatingActiveLayer){
			if(this.fireEvent(&#x27;layer-rotate&#x27;)){
				var dx &#x3D; x - this.activeLayer.x;
				var dy &#x3D; y - this.activeLayer.y;
				var angle &#x3D; Math.atan2(dy, dx);
				var degrees &#x3D; angle * 180 / Math.PI;
				this.activeLayer.rotation &#x3D; degrees;
				this.draw();
			}
		}else if(this.draggingActiveLayer){
			const newx &#x3D; this.activeLayerMouseOffset.x + x;
			const newy &#x3D; this.activeLayerMouseOffset.y + y;
			
			if(this.activeLayer.forceBoundary &amp;amp;&amp;amp; !this.isNewPosInBounds(this.activeLayer, newx, newy, this.activeLayer.width, this.activeLayer.height)){
				this.draggingActiveLayer &#x3D; false;
				this.draw();
				return;
			}
			
			if(this.fireEvent(&#x27;layer-drag&#x27;)){
				this.activeLayer.x &#x3D; newx;
				this.activeLayer.y &#x3D; newy;
				this.draw();
			}
		}else if(this.resizingActiveLayer){
			
			const {width, height} &#x3D; this.calculateLayerResize(x, y);
			if(this.activeLayer.forceBoundary &amp;amp;&amp;amp; !this.isNewPosInBounds(this.activeLayer, this.activeLayer.x, this.activeLayer.y, width, height)){
				this.draggingActiveLayer &#x3D; false;
				this.draw();
				return;
			}
			
			if(this.fireEvent(&#x27;layer-resize&#x27;)){
				this.activeLayer.width &#x3D; width;
				this.activeLayer.height &#x3D; height;
				this.draw();
			}
		}
	}
	
	/**
	 * Set the appropriate cursor.
	 * @ignore
	 */
	setCursor(x, y){
		if(this.rotatingActiveLayer){
			document.body.style.cursor &#x3D; this.cursors.rotating;
		}else if(this.draggingActiveLayer){
			document.body.style.cursor &#x3D; this.cursors.grabbing;
		}else if(this.resizingActiveLayer){
			document.body.style.cursor &#x3D; this.cursors.move;
		}else if(this.isNearActiveCorner(x, y)){
			document.body.style.cursor &#x3D; this.cursors.move;
		}else if(this.isNearActiveRotatePoint(x, y)){
			document.body.style.cursor &#x3D; this.cursors.rotate;
		}else if(this.isOverSelectableLayer(x, y)){
			document.body.style.cursor &#x3D; this.cursors.grab;
		}else{
			document.body.style.cursor &#x3D; this.cursors.default;
		}
	}
	
	/**
	 * Calculate new width and height of resizing image
	 * @ignore
	 */
	calculateLayerResize(x, y){
		var width &#x3D; this.activeLayer.width;
		var height &#x3D; this.activeLayer.height;
		
		var o &#x3D; this.lastMouseDownOffset;
		var n &#x3D; this.layerRelativePoint(x, y, this.activeLayer);
		if(o.x &gt; 0){
			width &#x3D; Math.abs(this.activeLayerOriginalDimensions.width - (o.x-n.x)*2);
		}else{
			width &#x3D; Math.abs(this.activeLayerOriginalDimensions.width - (n.x-o.x)*2);
		}
		if(o.y &gt; 0){
			height &#x3D; Math.abs(this.activeLayerOriginalDimensions.height - (o.y-n.y)*2);
		}else{
			height &#x3D; Math.abs(this.activeLayerOriginalDimensions.height - (n.y-o.y)*2);
		}
		if(this.shiftKeyDown){
			var ratio &#x3D; Math.min(
				width/this.activeLayerOriginalDimensions.width, 
				height/this.activeLayerOriginalDimensions.height
			);
			width &#x3D; this.activeLayerOriginalDimensions.width * ratio;
			height &#x3D; this.activeLayerOriginalDimensions.height * ratio;
		}
		
		return {width, height};
	}
	
	/**
	 * Fire an event.
	 * @ignore
	 */
	fireEvent(type){
		var event &#x3D; new CustomEvent(type, {detail: this, cancelable: true, bubbles: true});
		return this.canvas.dispatchEvent(event);
	}
	
	/**
	 * Listen for click event on a layer
	 * @ignore
	 */
	onclick(e){
		var {x, y} &#x3D; this.canvasMousePos(e);
		var lcl &#x3D; this.getLayerAt(x, y);
		if(lcl){
			this.last_clicked_layer &#x3D; lcl;
			this.fireEvent(&#x27;layer-click&#x27;);
		}
	}
	
	/**
	 * Listen for dbl click event on a layer
	 * @ignore
	 */
	ondblclick(e){
		var {x, y} &#x3D; this.canvasMousePos(e);
		var lcl &#x3D; this.getLayerAt(x, y);
		if(lcl){
			this.last_clicked_layer &#x3D; lcl;
			this.fireEvent(&#x27;layer-dblclick&#x27;);
		}
	}
	
	/**
	 * Handle mousedown over the canvas.
	 * @ignore
	 */
	onmousedown(e){
		var {x, y} &#x3D; this.canvasMousePos(e);
		this.setCursor(x, y);
		if(this.isNearActiveRotatePoint(x, y)){
			this.activeLayerRotateStartPos &#x3D; {x, y};
			this.rotatingActiveLayer &#x3D; true;
		}else if(this.isNearActiveCorner(x, y)){
			this.resizingActiveLayer &#x3D; true;
		}else{
			var cancelled &#x3D; false;
			var layer &#x3D; this.getLayerAt(x, y);
			if(layer !&#x3D;&#x3D; null &amp;amp;&amp;amp; layer.selectable &#x3D;&#x3D;&#x3D; false) layer &#x3D; null;
			if(layer !&#x3D;&#x3D; null &amp;amp;&amp;amp; this.activeLayer !&#x3D;&#x3D; null &amp;amp;&amp;amp; layer !&#x3D;&#x3D; this.activeLayer){
				cancelled &#x3D; !this.fireEvent(&#x27;layer-deselect&#x27;);
				if(!cancelled) !this.deSelectLayer();
			}
			if(!cancelled &amp;amp;&amp;amp; layer !&#x3D;&#x3D; null){
				this.activeLayerMouseOffset.x &#x3D; layer.x - x;
				this.activeLayerMouseOffset.y &#x3D; layer.y - y;
				if(layer.draggable) this.draggingActiveLayer &#x3D; true;
				if(layer !&#x3D;&#x3D; this.activeLayer){
					if(this.fireEvent(&#x27;layer-select&#x27;)){
						this.selectLayer(layer);
					}
				}
			}
		}
		if(this.activeLayer){
			this.activeLayerOriginalDimensions &#x3D; {
				width: this.activeLayer.width,
				height: this.activeLayer.height
			};
			this.lastMouseDownOffset &#x3D; this.layerRelativePoint(x, y, this.activeLayer);
		}
	}
	
	/**
	 * Are teh given coordinates near an active rotate anchor.
	 * @ignore
	 */
	isNearActiveRotatePoint(x, y){
		if(!this.activeLayer || !this.activeLayer.rotateable) return false;
		var {x, y} &#x3D; this.layerRelativePoint(x, y, this.activeLayer);
		var mx &#x3D; (this.activeLayer.width/2)+25;
		var my &#x3D; 0;
		var dist &#x3D; Math.hypot(mx-x, my-y);
		if(dist &amp;lt;&#x3D; this.getScale() * this.anchorRadius) return true;
		return false;
	}
	
	/**
	 * Are the given coordinates near an active resize anchor.
	 * @ignore
	 */
	isNearActiveCorner(x, y){
		if(!this.activeLayer || !this.activeLayer.resizable) return false;
		var {x, y} &#x3D; this.layerRelativePoint(x, y, this.activeLayer);
		var isNear &#x3D; false;
		this.activeLayer.getCorners().forEach(corner&#x3D;&gt;{			
			var dist &#x3D; Math.hypot(corner.x-x, corner.y-y);
			if(dist &amp;lt;&#x3D; this.getScale() * this.anchorRadius) isNear &#x3D; true;
		});
		return isNear;
	}
	
	/**
	 * Given a position, check if it is in bounds
	 * @ignore
	 */
	isNewPosInBounds(layer, x, y, width, height){
		var _x &#x3D; layer.x;
		var _y &#x3D; layer.y;
		var _width &#x3D; layer.width;
		var _height &#x3D; layer.height;
		
		layer.x &#x3D; x;
		layer.y &#x3D; y;
		layer.width &#x3D; width;
		layer.height &#x3D; height;
		
		var inbounds &#x3D; true;
		layer.getCorners().forEach(corner&#x3D;&gt;{
			var pos &#x3D; this.absolutePoint(corner.x, corner.y, layer.x, layer.y, layer.rotation);
			if(pos.x &amp;lt; 0 || pos.x &gt; this.width || pos.y &amp;lt; 0 || pos.y &gt; this.width){
				inbounds &#x3D; false;
			}
		});
		layer.x &#x3D; _x;
		layer.y &#x3D; _y;
		layer.width &#x3D; _width;
		layer.height &#x3D; _height;
		return inbounds;
	}
	
	/**
	 * Get the point relative to the center of a given layer.
	 * @ignore
	 */
	layerRelativePoint(absPointX, absPointY, layer){
		return this.relativePoint(absPointX, absPointY, layer.x, layer.y, layer.rotation);
	}
	
	/**
	 * Get the position of a point relative to another point and possibly rotated.
	 * @ignore
	 */
	relativePoint(absPointX, absPointY, centerX, centerY, rotation){
		absPointX -&#x3D; centerX;
		absPointY -&#x3D; centerY;
		var radians &#x3D; rotation * (Math.PI / 180);
		var cos &#x3D; Math.cos(radians);
		var sin &#x3D; Math.sin(radians);
		var x &#x3D; (absPointX * cos) + (absPointY * sin);
		var y &#x3D; (-absPointX * sin) + (absPointY * cos);
		x &#x3D; Math.floor(x * 100) / 100;
		y &#x3D; Math.floor(y * 100) / 100;
		return {x, y};
	}
	
	/**
	 * Convert a relative point to an absolute point.
	 * @ignore
	 */
	absolutePoint(relPointX, relPointY, centerX, centerY, rotationDegrees) {
		var radians &#x3D; rotationDegrees * (Math.PI / 180);
		var cos &#x3D; Math.cos(radians);
		var sin &#x3D; Math.sin(radians);
		var x &#x3D; centerX + (relPointX * cos) - (relPointY * sin);
		var y &#x3D; centerY + (relPointX * sin) + (relPointY * cos);
		return {x, y};
	}
	
	/**
	 * Get nearest grid line
	 * @ignore
	 */
	getNearestGridline(n, grid){
		return Object.values(grid.reduce((acc, val)&#x3D;&gt;{
			if(val &gt; n){
				if(null &#x3D;&#x3D;&#x3D; acc.high) acc.high &#x3D; val;
				else acc.high &#x3D; Math.min(acc.high, val);
			}else{
				if(null &#x3D;&#x3D;&#x3D; acc.low) acc.low &#x3D; val;
				else acc.low &#x3D; Math.max(acc.low, val);
			}
			return acc;
		}, {low: null, high: null})).reduce((acc, val)&#x3D;&gt;{
			var valDistToN &#x3D; Math.abs(val - n);
			var accDistToN &#x3D; acc &#x3D;&#x3D;&#x3D; null ? null : Math.abs(acc - n);
			if(acc &#x3D;&#x3D;&#x3D; null || valDistToN &amp;lt; accDistToN) acc &#x3D; val;
			return acc;
		}, null);
	}
	
	/**
	 * Handle mouseup or mouseout.
	 * @ignore
	 */
	onmousereset(e){
		if(this.draggingActiveLayer &amp;amp;&amp;amp; this.snapToGrid &amp;amp;&amp;amp; this.activeLayer){
			var {xs, ys} &#x3D; this.getGridLines();
			var closestx &#x3D; this.getNearestGridline(this.activeLayer.x, xs);
			var closesty &#x3D; this.getNearestGridline(this.activeLayer.y, ys);
			var redraw_required &#x3D; false;
			var dist &#x3D; Math.abs(closestx - this.activeLayer.x);
			if(dist &amp;lt;&#x3D; this.gridDistancePixels &amp;amp;&amp;amp; dist !&#x3D;&#x3D; 0){
				this.activeLayer.x &#x3D; closestx;
				redraw_required &#x3D; true;
			}
			dist &#x3D; Math.abs(closesty - this.activeLayer.y);
			if(dist &amp;lt;&#x3D; this.gridDistancePixels &amp;amp;&amp;amp; dist !&#x3D;&#x3D; 0){
				this.activeLayer.y &#x3D; closesty;
				redraw_required &#x3D; true;
			}
			if(redraw_required){
				this.draw();
			}
		}
		if(this.draggingActiveLayer || this.resizingActiveLayer || this.rotatingActiveLayer) this.saveState();
		var {x, y} &#x3D; this.canvasMousePos(e);
		this.draggingActiveLayer &#x3D; false;
		this.resizingActiveLayer &#x3D; false;
		this.rotatingActiveLayer &#x3D; false;
		this.lastMouseDownOffset &#x3D; {x:0, y:0};
		this.activeLayerMouseOffset &#x3D; {x:0, y:0};
		this.activeLayerOriginalDimensions &#x3D; {width:0, height:0};
		this.activeLayerRotateStartPos &#x3D; {x:0, y:0};
		this.setCursor(x, y);
	}
	
	/**
	 * Get the scale of the canvas
	 * @ignore
	 */
	getScale(){
		var rect &#x3D; this.canvas.getBoundingClientRect();
		return this.canvas.width / rect.width;
	}
	
}

/**
 * The version of the library
 * @type {String}
 */
Canvas.version &#x3D; &#x27;1.1.61&#x27;;

/**
 * The default anchorRadius value for all Canvas instances.
 * @type {Number}
 */
Canvas.anchorRadius &#x3D; 8;

/**
 * The default strokeStyle value for all Canvas instances.
 * @type {String}
 */
Canvas.strokeStyle &#x3D; &#x27;#ba0000&#x27;;

/**
 * The default fillStyle value for all Canvas instances.
 * @type {String}
 */
Canvas.fillStyle &#x3D; &#x27;black&#x27;;

/**
 * The default lineWidth value for all Canvas instances.
 * @type {Number}
 */
Canvas.lineWidth &#x3D; 5;

/**
 * The default Cursor values for all Canvas instances. See the canvas constructor for details.
 * @type {Object}
 * @property {String} Canvas.cursors.default
 * @property {String} Canvas.cursors.grab
 * @property {String} Canvas.cursors.grabbing
 * @property {String} Canvas.cursors.move
 * @property {String} Canvas.cursors.rotate
 * @property {String} Canvas.cursors.rotating
 */
Canvas.cursors &#x3D; {
	default: null,
	grab: &quot;grab&quot;,
	grabbing: &quot;grabbing&quot;,
	move: &quot;crosshair&quot;,
	rotate: &quot;grab&quot;,
	rotating: &quot;grabbing&quot;
};


/**
 * Class representing the layers drawn on the canvas.
 */
class CanvasLayer{
	
	/**
	 * Create a new Layer.
	 * @param {String} url - The URL or URI of an image to draw on the canvas.
	 * @param {String} name - The name of the layer.
	 * @param {Number} x - The x position of the layer on the canvas.
	 * @param {Number} y - The y position of the layer on the canvas.
	 * @param {Number} [width&#x3D;null] - The width of the layer on the canvas.
	 * @param {Number} [height&#x3D;null] - The height of the layer on the canvas.
	 * @param {Number} [rotation&#x3D;0] - The rotation of the layer on the canvas.
	 * @param {Boolean} [draggable&#x3D;true] - Is the layer draggable?
	 * @param {Boolean} [rotateable&#x3D;true] - Is the layer rotateable?
	 * @param {Boolean} [resizable&#x3D;true] - Is the layer resizable?
	 * @param {Boolean} [selectable&#x3D;true] - Is the layer selectable?
	 * @param {Boolean} [forceBoundary&#x3D;false] - Force the layer to stay in bounds?
	 * @returns {CanvasLayer}
	 */
	constructor(url, name, x, y, width&#x3D;null, height&#x3D;null, rotation&#x3D;0, draggable&#x3D;true, rotateable&#x3D;true, resizable&#x3D;true, selectable&#x3D;true, forceBoundary&#x3D;false){
		this.name &#x3D; name;
		this.url &#x3D; url;
		this.ready &#x3D; false;
		this.image &#x3D; null;
		this.x &#x3D; x;
		this.y &#x3D; y;
		this.width &#x3D; width;
		this.height &#x3D; height;
		this.rotation &#x3D; rotation;
		this.draggable &#x3D; draggable;
		this.rotateable &#x3D; rotateable;
		this.resizable &#x3D; resizable;
		this.selectable &#x3D; selectable;
		this.forceBoundary &#x3D; forceBoundary;
		this.load_cb_stack &#x3D; [];
		this.load();
	}
	
	/**
	 * jsonify the current layer
	 * @returns {String} - Serialized layer
	 */
	objectify(){
		return {
			layer: this, 
			state: {
				name: this.name,
				url: this.url,
				x: this.x,
				y: this.y,
				width: this.width,
				height: this.height,
				rotation: this.rotation,
				draggable: this.draggable,
				rotatable: this.rotateable,
				resizable: this.resizable,
				selectable: this.selectable,
				forceBoundary: this.forceBoundary
			}
		};
	}
	
	/**
	 * Register a function to be called when the layer is fully loaded.
	 * @param {Function} fn - The callback function.
	 * @returns {undefined}
	 */
	onload(fn){
		if(this.ready){
			fn();
			return;
		}else{
			this.load_cb_stack.push(fn);
		}
	}
	
	/**
	 * Load the layer so it is ready to use.
	 * @returns {Promise} - A promise that resolves when the layer is ready
	 */
	load(){
		return new Promise(done&#x3D;&gt;{
			if(this.ready){
				done();
			}else{
				const img &#x3D; new Image();
				img.onload &#x3D; ()&#x3D;&gt;{
					this.image &#x3D; img;
					if(this.width&#x3D;&#x3D;&#x3D;null) this.width &#x3D; img.width;
					if(this.height&#x3D;&#x3D;&#x3D;null) this.height &#x3D; img.height;
					this.ready &#x3D; true;
					this.load_cb_stack.forEach(fn&#x3D;&gt;fn());
					this.load_cb_stack &#x3D; [];
				};
				img.src &#x3D; this.url;
			}
		});
	}
	
	/**
	 * Get the relative position of all the corners.
	 * @ignore
	 */
	getCorners(){
		return [
			{x:-(this.width/2), y:-(this.height/2)},
			{x:-(this.width/2)+this.width, y:-(this.height/2)},
			{x:-(this.width/2)+this.width, y:-(this.height/2)+this.height},
			{x:-(this.width/2), y:-(this.height/2)+this.height}
		];
	}
	
}

/**
 * un Serialize a layer
 * @param {type} str
 * @returns {CanvasLayer}
 */
CanvasLayer.deobjectify &#x3D; function(d){
	var layer &#x3D; d.layer;
	Object.keys(d.state).forEach(key&#x3D;&gt;{
		layer[key] &#x3D; d.state[key];
	});
	return layer;
};</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 3.6.2 on July 31, 2019.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/jquery.cookie.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>