<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 3.6.2">
  <meta charset="utf-8">
  <title>Source: canvas-layers.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: canvas-layers.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>/**
 * canvas-layers - v2.0.1
 * Allow user to position and re-arrange images on a canvas.
 * @author Pamblam
 * @website 
 * @license MIT
 */


/**
 * Interface for handling all canvas functionality
 * @see https://pamblam.github.io/canvas-layers/examples/
 * @version 2.0.1
 */
class Canvas{
	
	/**
	 * Construct a new instance of the Canvas class
	 * @param {HTMLElement} canvas - The canvas to instantiate the class upon.
	 * @param {Number} [opts.anchorRadius&#x3D;Canvas.anchorRadius] - The radius of the anchor points shown on selected elements.
	 * @param {String} [opts.strokeStyle&#x3D;Canvas.strokeStyle] - The color of the outlines drawn on selceted elements. May be any valid CSS color string.
	 * @param {String} [opts.fillStyle&#x3D;Canvas.fillStyle] - The color of the anchor points shown on selected elements. May be any valid CSS color string.
	 * @param {Number} [opts.lineWidth&#x3D;Canvas.lineWidth] - The width of the outlines shown on selected elements.
	 * @param {String} [opts.cursors.default&#x3D;Canvas.cursors.default] - The default cursor to use when hovering over the canvas. May be any valid css cursor value.
	 * @param {String} [opts.cursors.grab&#x3D;Canvas.cursors.grab] - The grab cursor to use when hovering over a movable layer. May be any valid css cursor value.
	 * @param {String} [opts.cursors.grabbing&#x3D;Canvas.cursors.grabbing] - The grabbing cursor to use when dragging a layer. May be any valid css cursor value.
	 * @param {String} [opts.cursors.move&#x3D;Canvas.cursors.move] - The default cursor to use when hovering over a resize anchor. May be any valid css cursor value.
	 * @param {String} [opts.cursors.rotate&#x3D;Canvas.cursors.rotate] - The default cursor to use when hovering a rotate anchor point. May be any valid css cursor value.
	 * @param {String} [opts.cursors.rotating&#x3D;Canvas.cursors.rotating] - The default cursor to use when rotating an active layer. May be any valid css cursor value.
	 * @returns {Canvas}
	 */
	constructor(canvas, opts&#x3D;{}){
		this.canvas &#x3D; canvas;
		this.width &#x3D; canvas.width;
		this.height &#x3D; canvas.height;
		this.ctx &#x3D; canvas.getContext(&#x27;2d&#x27;);
		this.layers &#x3D; [];
		this.layer_state_pos &#x3D; -1;
		this.layer_states &#x3D; [];
		this.drawPromises &#x3D; [];
		this.activeLayer &#x3D; null;
		this.shiftKeyDown &#x3D; false;
		this.draggingActiveLayer &#x3D; false;
		this.resizingActiveLayer &#x3D; false;
		this.rotatingActiveLayer &#x3D; false;
		this.lastMouseDownOffset &#x3D; {x:0, y:0};
		this.activeLayerMouseOffset &#x3D; {x:0, y:0};
		this.activeLayerOriginalDimensions &#x3D; {width:0, height:0};
		this.activeLayerRotateStartPos &#x3D; {x:0, y:0};
		this.displayGrid &#x3D; false;
		this.snapToGrid &#x3D; false;
		this.gridDistancePixels &#x3D; 10;
		
		canvas.addEventListener(&#x27;mousemove&#x27;, this.onmousemove.bind(this));
		canvas.addEventListener(&#x27;mousedown&#x27;, this.onmousedown.bind(this));
		canvas.addEventListener(&#x27;mouseout&#x27;, this.onmousereset.bind(this));
		canvas.addEventListener(&#x27;mouseup&#x27;, this.onmousereset.bind(this));
		canvas.addEventListener(&#x27;click&#x27;, this.onclick.bind(this));
		canvas.addEventListener(&#x27;dblclick&#x27;, this.ondblclick.bind(this));
		document.addEventListener(&#x27;keydown&#x27;, this.onkeyevent.bind(this));
		document.addEventListener(&#x27;keyup&#x27;, this.onkeyevent.bind(this));
		
		this.anchorRadius &#x3D; opts.anchorRadius || Canvas.anchorRadius;
		this.strokeStyle &#x3D; opts.strokeStyle || Canvas.strokeStyle;
		this.fillStyle &#x3D; opts.fillStyle || Canvas.fillStyle;
		this.lineWidth &#x3D; opts.lineWidth || Canvas.lineWidth;
		this.cursors &#x3D; opts.cursors || {};
		this.cursors.default &#x3D; this.cursors.default || Canvas.cursors.default;
		this.cursors.grab &#x3D; this.cursors.grab || Canvas.cursors.grab;
		this.cursors.grabbing &#x3D; this.cursors.grabbing || Canvas.cursors.grabbing;
		this.cursors.move &#x3D; this.cursors.move || Canvas.cursors.move;
		this.cursors.rotate &#x3D; this.cursors.rotate || Canvas.cursors.rotate;
		this.cursors.rotating &#x3D; this.cursors.rotating || Canvas.cursors.rotating;
		this.last_clicked_layer &#x3D; null;
		this.pending_layers &#x3D; 0;
		this.ready &#x3D; true;
		
		// if turned on, no state will be saved.
		this.muteStateChanges &#x3D; false;
		this.isCtrlPressed &#x3D; false;
		this.ctrlGroupLayer &#x3D; new CanvasLayerGroup(&#x27;ctrl-grp&#x27;);
	}	
	
	/**
	 * Is the provided layer part of the ctrl-grp
	 * @param {CavnasLayer} layer
	 * @returns {Boolean}
	 */
	isLayerInGroup(layer){
		return !!~this.ctrlGroupLayer.layers.indexOf(layer);
	}
	
	/**
	 * Is the ctrl-grp on the canvas?
	 * @returns {Boolean}
	 */
	isGroupOnCanvas(){ 
		return !!~this.layers.indexOf(this.ctrlGroupLayer) 
	}
	
	/**
	 * Remove the ctrl-grp from the canvas
	 * @returns {Promise}
	 */
	async destroyCtrlGroup(){
		this.muteStateChanges &#x3D; true;
		var promises &#x3D; this.ctrlGroupLayer.layers.map(layer&#x3D;&gt;{
			return new Promise(done&#x3D;&gt;{
				this.addLayer(layer);
				layer.onload(()&#x3D;&gt;done());
			});
		});
		await Promise.all(promises);
		this.ctrlGroupLayer.layers &#x3D; [];
		this.ctrlGroupLayer.rotation &#x3D; 0;
		if(this.isGroupOnCanvas()) this.removeLayer(this.ctrlGroupLayer);
		this.muteStateChanges &#x3D; false;
	}
	
	/**
	 * Load the state object
	 * @param {type} state
	 * @returns {undefined}
	 */
	loadState(state){
		this.layers &#x3D; state.map(s&#x3D;&gt;CanvasLayer.deobjectify(s));
		this.draggingActiveLayer &#x3D; false;
		this.resizingActiveLayer &#x3D; false;
		this.rotatingActiveLayer &#x3D; false;
		this.lastMouseDownOffset &#x3D; {x:0, y:0};
		this.activeLayerMouseOffset &#x3D; {x:0, y:0};
		this.activeLayerOriginalDimensions &#x3D; {width:0, height:0};
		this.activeLayerRotateStartPos &#x3D; {x:0, y:0};
		this.draw();
	}
	
	/**
	 * saves the current state in the state stack
	 * @returns {undefined}
	 */
	saveState(){
		if(this.muteStateChanges) return;
		var state &#x3D; [];
		const getState &#x3D; (layers) &#x3D;&gt; {
			layers.forEach(layer&#x3D;&gt;{
				if(layer instanceof CanvasLayerGroup) getState(layer.layers);
				else state.push(layer.objectify());
			});
		}
		getState(this.layers);
		this.layer_states.length &#x3D; this.layer_state_pos+1;
		this.layer_states.push(state);
		this.layer_state_pos &#x3D; this.layer_states.length-1;
	}
	
	/**
	 * Undo an action
	 * @returns {undefined}
	 */
	undo(){
		if(this.layer_state_pos&gt;0){
			this.layer_state_pos--;
			this.loadState(this.layer_states[this.layer_state_pos]);
		}
	}
	
	/**
	 * Redo the last un-did action
	 * @returns {undefined}
	 */
	redo(){
		if((this.layer_state_pos+1)&amp;lt;this.layer_states.length){
			this.layer_state_pos++;
			this.loadState(this.layer_states[this.layer_state_pos]);
		}
	}
	
	/**
	 * Enable snap to grid
	 * @returns {undefined}
	 */
	snapOn(gridDistancePixels&#x3D;10){
		this.snapToGrid &#x3D; true;
		gridDistancePixels &#x3D; +gridDistancePixels &amp;lt; 3 ? 3 : +gridDistancePixels;
		this.gridDistancePixels &#x3D; gridDistancePixels;
	}
	
	/**
	 * Disable snap to grid
	 * @returns {undefined}
	 */
	snapOff(){
		this.snapToGrid &#x3D; false;
		this.draw();
	}
	
	/**
	 * Show the grid lines on the canvas
	 * @returns {undefined}
	 */
	showGrid(gridDistancePixels&#x3D;10){
		this.displayGrid &#x3D; true;
		gridDistancePixels &#x3D; +gridDistancePixels &amp;lt; 3 ? 3 : +gridDistancePixels;
		this.gridDistancePixels &#x3D; gridDistancePixels;
		this.draw();
	}
	
	/**
	 * Hide the grid lines on the canvas
	 * @returns {undefined}
	 */
	hideGrid(){
		this.displayGrid &#x3D; false;
		this.draw();
	}
	
	/**
	 * Get a layer by it&#x27;s given name.
	 * @param {String} name - The name of the layer. 
	 * @returns {CanvasLayer|null}
	 */
	getLayerByName(name){
		for(var i&#x3D;this.layers.length; i--;){
			if(this.layers[i].name &#x3D;&#x3D;&#x3D; name) return this.layers[i];
		}
		return null;
	}
	
	/**
	 * Add a layer to the canvas.
	 * @param {String} url - The URI or URL of an image to draw on the canvas.
	 * @param {String} [opts.name&#x3D;&quot;Layer n&quot;] - The name of the layer.
	 * @param {Number} [opts.x&#x3D;this.width/2] - The x position of the layer.
	 * @param {Number} [opts.y&#x3D;this.height/2] - The y position of the layer.
	 * @param {Number} [opts.rotation&#x3D;0] - The rotation of the layer, counter-clockwise, in degrees.
	 * @param {Boolean} [opts.draggable&#x3D;true] - Can the user move this layer?
	 * @param {Boolean} [opts.rotateable&#x3D;true] - Can the user rotate this layer?
	 * @param {Boolean} [opts.resizable&#x3D;true] - Can the user resize this layer?
	 * @param {Boolean} [opts.selectable&#x3D;true] - Can the user select this layer?
	 * @param {Number} [opts.width&#x3D;null] - The width of the layer to be drawn. If not specified, defaults to the images natural width.
	 * @param {Number} [opts.height&#x3D;null] - The height of the layer to be drawn. If not specified, defaults to the images natural height.
	 * @param {Boolean} [opts.forceBoundary&#x3D;false] - Force the item to stay in bounds.
	 * @param {Boolean} [opts.allowOverlap&#x3D;true] - Allow layers to overlap with this one.
	 * @returns {CanvasLayer} - The layer that was added.
	 */
	addLayer(layerOrURL, opts&#x3D;{}){
		this.ready &#x3D; false;
		if(layerOrURL instanceof CanvasLayer){
			var layer &#x3D; layerOrURL;
		}else{
			const name &#x3D; opts.name || &#x60;Layer ${this.layers.length}&#x60;;
			const x &#x3D; parseFloat(opts.x || this.width/2);
			const y &#x3D; parseFloat(opts.y || this.height/2);
			const rotation &#x3D; parseFloat(opts.rotation || 0);
			const draggable &#x3D; opts.draggable &#x3D;&#x3D;&#x3D; undefined ? true : opts.draggable;
			const rotateable &#x3D; !!opts.rotateable &#x3D;&#x3D;&#x3D; undefined ? true : opts.rotateable;
			const resizable &#x3D; !!opts.resizable &#x3D;&#x3D;&#x3D; undefined ? true : opts.resizable;
			const selectable &#x3D; !!opts.selectable &#x3D;&#x3D;&#x3D; undefined ? true : opts.selectable;
			const width &#x3D; opts.width || null;
			const height &#x3D; opts.height || null;
			const forceBoundary &#x3D; opts.forceBoundary || false;
			const allowOverlap &#x3D; opts.hasOwnProperty(&#x27;allowOverlap&#x27;) ? !!opts.allowOverlap : true;
			var layer &#x3D; new CanvasLayer(layerOrURL, name, x, y, width, height, rotation, draggable, rotateable, resizable, selectable, forceBoundary, allowOverlap);
		}
		
		this.layers.unshift(layer);
		this.pending_layers++;
		
		layer.onload(()&#x3D;&gt;{
			this.pending_layers--;
			if(0 &#x3D;&#x3D;&#x3D; this.pending_layers){
				this.ready &#x3D; true;
				this.draw();
				this.saveState();
				
				if(!(layer instanceof CanvasLayerGroup)){
					this.fireEvent(&#x27;layer-added&#x27;);
				}
				
			}
		});
		return layer;
	}
	
	/**
	 * Rotate and crop the canvas to the dimensions and rotation of the specified layer.
	 * @param {CanvasLayer} layer - The layer to crop to.
	 * @returns {Promise} - A Promise htat resolves with the DataURI of the cropped area.
	 */
	cropToLayer(layer, unrotated&#x3D;true){
		return this.extractPortion(layer.x, layer.y, layer.width, layer.height, layer.rotation, unrotated);
	}
	
	/**
	 * Rotate and extract a custom area of the canvas.
	 * @param {Number} centerx - The x position of the center of the area to extract.
	 * @param {Number} centery - The y position of the center of the area to extract.
	 * @param {Number} width - The width of the area to extract from teh canvas.
	 * @param {Number} height - The height of the area to extract from teh canvas.
	 * @param {Number} [rotation&#x3D;0] - The rotation of the area to extract, counter-clockwise, in degrees.
	 * @param {Boolean} [unrotated&#x3D;true] - If true, undo the rotation so the layer is in it&#x27;s natural position.
	 * @returns {Promise} - A Promise htat resolves with the DataURI of the cropped area.
	 */
	async extractPortion(centerx, centery, width, height, rotation&#x3D;0, unrotated&#x3D;true){
		var radians &#x3D; rotation * Math.PI / 180;
		var {x, y} &#x3D; Canvas.absolutePoint(-(width/2), -(height/2), centerx, centery, rotation);
		
		var rectBB &#x3D; this.getRotatedRectBB(x, y, width, height, radians);
		
		var canvas0 &#x3D; document.createElement(&quot;canvas&quot;);
		var ctx0 &#x3D; canvas0.getContext(&quot;2d&quot;);
		var canvas1 &#x3D; document.createElement(&quot;canvas&quot;);
		var ctx1 &#x3D; canvas1.getContext(&quot;2d&quot;);
		var canvas2 &#x3D; document.createElement(&quot;canvas&quot;);
		var ctx2 &#x3D; canvas2.getContext(&quot;2d&quot;);
		
		canvas1.width &#x3D; canvas2.width &#x3D; rectBB.width;
		canvas1.height &#x3D; canvas2.height &#x3D; rectBB.height;
		canvas0.width &#x3D; this.width;
		canvas0.height &#x3D; this.height;
		
		await this.loadAll();
		
		for(let i&#x3D;this.layers.length; i--;){
			let layer &#x3D; this.layers[i];
			var radians &#x3D; layer.rotation * (Math.PI/180);
			ctx0.translate(layer.x, layer.y);
			ctx0.rotate(radians);
			ctx0.drawImage(layer.image, -(layer.width/2), -(layer.height/2), layer.width, layer.height);
			ctx0.rotate(-radians);
			ctx0.translate(-layer.x, -layer.y);
		}

		ctx1.drawImage(canvas0, rectBB.cx - rectBB.width / 2, rectBB.cy - rectBB.height / 2, rectBB.width, rectBB.height, 0, 0, rectBB.width, rectBB.height);
		
		if(!unrotated){
			return canvas1.toDataURL();
		}
		
		ctx2.translate(canvas1.width / 2, canvas1.height / 2);
		ctx2.rotate(-radians);
		ctx2.drawImage(canvas1, -canvas1.width / 2, -canvas1.height / 2);
		var ofstx &#x3D; (canvas2.width - width) / 2;
		var ofsty &#x3D; (canvas2.height - height) / 2;
		ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
		canvas1.width &#x3D; width;
		canvas1.height &#x3D; height;
		ctx1.drawImage(canvas2, -ofstx, -ofsty);
		return canvas1.toDataURL();
	}
	
	
	/**
	 * Draw the canvas.
	 * @returns {Promise}
	 */
	draw(){
		return new Promise(done&#x3D;&gt;{
			this.drawPromises.push(done);
			if(!this.ready) return;

			this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
			for(let i&#x3D;this.layers.length; i--;){
				let layer &#x3D; this.layers[i];
				var radians &#x3D; layer.rotation * (Math.PI/180);
				this.ctx.translate(layer.x, layer.y);
				this.ctx.rotate(radians);

				this.ctx.drawImage(layer.image, -(layer.width/2), -(layer.height/2), layer.width, layer.height);

				if(layer &#x3D;&#x3D;&#x3D; this.activeLayer){
					this.ctx.strokeStyle &#x3D; this.strokeStyle;
					this.ctx.fillStyle &#x3D; this.fillStyle;
					this.ctx.lineWidth &#x3D; this.getScale() * this.lineWidth;
					this.ctx.strokeRect(-(layer.width/2), -(layer.height/2), layer.width, layer.height);
					if(layer.resizable){
						layer.getCorners().forEach(corner&#x3D;&gt;{
							this.drawCircle(corner.x, corner.y, this.getScale() * this.anchorRadius);
						});
					}
					if(layer.rotateable){
						this.ctx.beginPath();
						this.ctx.moveTo(0, 0);
						this.ctx.lineTo((layer.width/2)+25, 0);
						this.ctx.stroke();
						this.drawCircle((layer.width/2)+25, 0, this.getScale() * this.anchorRadius);
					}
				}
				this.ctx.rotate(-radians);
				this.ctx.translate(-layer.x, -layer.y);
			}

			if(this.displayGrid){
				this.ctx.strokeStyle &#x3D; &quot;rgba(0,0,0,0.2)&quot;;
				this.ctx.lineWidth &#x3D; this.getScale() * 2;
				var {xs, ys} &#x3D; this.getGridLines(false);
				xs.forEach(x&#x3D;&gt;{
					this.ctx.beginPath();
					this.ctx.moveTo(x, 0);
					this.ctx.lineTo(x, this.canvas.height);
					this.ctx.stroke(); 
				});
				ys.forEach(y&#x3D;&gt;{
					this.ctx.beginPath();
					this.ctx.moveTo(0, y);
					this.ctx.lineTo(this.canvas.width, y);
					this.ctx.stroke(); 
				});
			}
			
			while(this.drawPromises.length) this.drawPromises.shift()();
		});
	}	
	
	/**
	 * Remove all layers from teh canvas.
	 * @returns {undefined}
	 */
	removeAllLayers(){
		this.deSelectLayer();
		this.layers &#x3D; [];
		this.draw();
	}
	
	/**
	 * Remove the specified layer from the canvas.
	 * @param {CanvasLayer} layer - The layer to remove
	 * @returns {undefined}
	 */
	removeLayer(layer){
		if(layer &#x3D;&#x3D;&#x3D; this.activeLayer) this.deSelectLayer();
		this.layers.splice(this.layers.indexOf(layer), 1);
		this.saveState();
		this.draw();
	}
	
	/**
	 * Select the given layer.
	 * @param {CanvasLayer} layer - The layer to select.
	 * @returns {undefined}
	 */
	selectLayer(layer){
		this.layers.unshift(this.layers.splice(this.layers.indexOf(layer), 1)[0]);
		this.activeLayer &#x3D; layer;
		this.draw();
		this.fireEvent(&#x27;layer-selected&#x27;);
	}
	
	/**
	 * Deselect the selected layer if one is selected.
	 * @returns {undefined}
	 */
	deSelectLayer(){
		this.activeLayer &#x3D; null;
		this.draggingActiveLayer &#x3D; false;
		this.draw();
		this.fireEvent(&#x27;layer-deselected&#x27;);
	}
	
	/**
	 * Get the cooresponding coordinates of the mouses position on the canvas.
	 * @param {MouseEvent} e - The event passed to a mouse event handler.
	 * @returns {{x: Number, y: Number}}
	 */
	canvasMousePos(e) {
		var rect &#x3D; this.canvas.getBoundingClientRect();
		var x &#x3D; e.clientX - rect.left;
		var y &#x3D; e.clientY - rect.top;
		var wfactor &#x3D; this.canvas.width / rect.width;
		var hfactor &#x3D; this.canvas.height / rect.height;
		x &#x3D; x*wfactor;
		y &#x3D; y*hfactor;
		return {x, y};
	}
	
	/**
	 * Get the layer at the given canvas coordinates.
	 * @param {Number} x - The x ordinate.
	 * @param {Number} y - The y ordinate.
	 * @returns {CanvasLayer|null}
	 */
	getLayerAt(x, y){
		for(let i&#x3D;0; i&amp;lt;this.layers.length; i++){
			let layer &#x3D; this.layers[i];
			if(Canvas.isOverLayer(x, y, layer)) return layer;
		}
		return null;
	}
	
	/**
	 * Are the given coordinates over a selectable layer?
	 * @param {Number} x - The x ordinate.
	 * @param {Number} y - The y ordinate.
	 * @returns {Boolean}
	 */
	isOverSelectableLayer(x, y){
		for(let i&#x3D;this.layers.length; i--;){
			if(Canvas.isOverLayer(x, y, this.layers[i])){
				if(this.layers[i].selectable &amp;amp;&amp;amp; this.activeLayer !&#x3D;&#x3D; this.layers[i]) return true;
			}
		}
		return false;
	}
	
	/**
	 * Get an array of all layers that the given layer overlaps.
	 * @param {type} layer
	 * @returns {Array|Canvas.getOverlappingLayers.layers}
	 */
	getOverlappingLayers(layer){
		var layers &#x3D; [];
		for(var i&#x3D;0; i&amp;lt;this.layers.length; i++){
			if(this.layers[i] &#x3D;&#x3D;&#x3D; layer) continue;
			if(this.doLayersOverlap(layer, this.layers[i])){
				layers.push(this.layers[i]);
			}			
		}
		return layers;
	}
	
	////////////////////////////////////////////////////////////////////////////
	// Undocumented utility layers /////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////
	
	/**
	 * Get an object containing arrays of x and y grid line positons
	 * @param {Boolean} snap - If true, get lines to snap to, else get lines to display
	 * @returns {Object} - An object with an &#x27;xs&#x27; property containing x positions and a &#x27;ys&#x27; property containing y positions;
	 */
	getGridLines(snap&#x3D;true){
		var xs &#x3D; [];
		var ys &#x3D; [];
		var dist &#x3D; 0;
		
		if(snap){
			dist &#x3D; this.gridDistancePixels;
		}else{
			dist &#x3D; this.gridDistancePixels * 2;
		}
		
		for(var x&#x3D;0; x&amp;lt;this.canvas.width; x +&#x3D; (this.getScale() * dist)){
			xs.push(x); 
		}
		for(var y&#x3D;0; y&amp;lt;this.canvas.height; y +&#x3D; (this.getScale() * dist)){
			ys.push(y);
		}
		for(let i&#x3D;this.layers.length; i--;){
			if(snap &amp;amp;&amp;amp; this.layers[i] &#x3D;&#x3D;&#x3D; this.activeLayer) continue;
			xs.push(this.layers[i].x);
			ys.push(this.layers[i].y);
		}
		[...new Set(xs)].sort();
		[...new Set(ys)].sort();
		return {xs, ys};
	}
	
	/**
	 * Load all layers.
	 * @ignore
	 */
	loadAll(){
		var promises &#x3D; this.layers.map(layer&#x3D;&gt;layer.load());
		return Promise.all(promises);
	}
	
	/**
	 * Get the bounding box of the defined area.
	 * @ignore
	 */
	getRotatedRectBB(x, y, width, height, rAngle) {
		var absCos &#x3D; Math.abs(Math.cos(rAngle));
		var absSin &#x3D; Math.abs(Math.sin(rAngle));
		var cx &#x3D; x + width / 2 * Math.cos(rAngle) - height / 2 * Math.sin(rAngle);
		var cy &#x3D; y + width / 2 * Math.sin(rAngle) + height / 2 * Math.cos(rAngle);
		var w &#x3D; width * absCos + height * absSin;
		var h &#x3D; width * absSin + height * absCos;
		return ({
			cx: cx,
			cy: cy,
			width: w,
			height: h
		});
	}
	
	/**
	 * Draw a circle on the canvas.
	 * @ignore
	 */
	drawCircle(x, y, radius){
		this.ctx.beginPath();
		this.ctx.arc(x, y, radius, 0, Math.PI*2, true); 
		this.ctx.closePath();
		this.ctx.fill();
	}
	
	/**
	 * Handle key down and keyup.
	 * @ignore
	 */
	onkeyevent(e){
		if(&#x27;Shift&#x27; &#x3D;&#x3D;&#x3D; e.key){
			if(e.type &#x3D;&#x3D;&#x3D; &#x27;keydown&#x27;) this.shiftKeyDown &#x3D; true;
			else this.shiftKeyDown &#x3D; false
		}
		if(&#x27;Control&#x27; &#x3D;&#x3D;&#x3D; e.key){
			if(e.type &#x3D;&#x3D;&#x3D; &#x27;keydown&#x27;) this.isCtrlPressed &#x3D; true;
			else this.isCtrlPressed &#x3D; false
		}
		if(!this.isCtrlPressed &amp;amp;&amp;amp; this.isGroupOnCanvas()){
			this.destroyCtrlGroup();
		}
	}
	
	/**
	 * Check if two given layers overlap
	 * @param {CanvasLayer} layer1
	 * @param {CanvasLayer} layer2
	 * @returns {Boolean}
	 */
	doLayersOverlap(layer1, layer2){
		const abs_corners &#x3D; l &#x3D;&gt; l.getCorners().map(c&#x3D;&gt;Canvas.absolutePoint(c.x, c.y, l.x, l.y, l.rotation));
		const corners_to_lines &#x3D; c &#x3D;&gt; [
			[{x:c[0].x, y:c[0].y},{x:c[1].x, y:c[1].y}],
			[{x:c[1].x, y:c[1].y},{x:c[2].x, y:c[2].y}],
			[{x:c[2].x, y:c[2].y},{x:c[3].x, y:c[3].y}],
			[{x:c[3].x, y:c[3].y},{x:c[0].x, y:c[0].y}]
		];
		
		var l1_corners &#x3D; abs_corners(layer1);
		var l1_lines &#x3D; corners_to_lines(l1_corners);
		
		var l2_corners &#x3D; abs_corners(layer2);
		var l2_lines &#x3D; corners_to_lines(l2_corners);
		
		// Check if any of the edges intersect
		// This covers partial overlaps.
		for(let n1&#x3D;0; n1&amp;lt;l1_lines.length; n1++){
			for(let n2&#x3D;0; n2&amp;lt;l2_lines.length; n2++){
				let a &#x3D; l1_lines[n1][0].x;
				let b &#x3D; l1_lines[n1][0].y;
				let c &#x3D; l1_lines[n1][1].x;
				let d &#x3D; l1_lines[n1][1].y;
				let p &#x3D; l2_lines[n2][0].x;
				let q &#x3D; l2_lines[n2][0].y;
				let r &#x3D; l2_lines[n2][1].x;
				let s &#x3D; l2_lines[n2][1].y;
				if(Canvas.doLinesIntersect(a, b, c, d, p, q, r, s)) return true;
			}
		}
		
		// Check for one corner. This covers full overlaps.
		var c1 &#x3D; layer1.getCorners()[0];
		c1 &#x3D; Canvas.absolutePoint(c1.x, c1.y, layer1.x, layer1.y, layer1.rotation);
		if(Canvas.isOverLayer(c1.x, c1.y, layer2)) return true;
		
		var c2 &#x3D; layer2.getCorners()[0];
		c2 &#x3D; Canvas.absolutePoint(c2.x, c2.y, layer2.x, layer2.y, layer2.rotation);
		if(Canvas.isOverLayer(c2.x, c2.y, layer1)) return true;
		
		return false;
	}
	
	/**
	 * Returns true if the active layer can be moved to the specified coordinates.
	 * @ignore
	 */
	canMoveActiveLayer(newx, newy){
		const inBounds &#x3D; this.isNewPosInBounds(this.activeLayer, newx, newy, this.activeLayer.width, this.activeLayer.height);
		if(this.activeLayer.forceBoundary &amp;amp;&amp;amp; !inBounds) return false;
		
		var x &#x3D; this.activeLayer.x;
		var y &#x3D; this.activeLayer.y;
		this.activeLayer.x &#x3D; newx;
		this.activeLayer.y &#x3D; newy;
		
		var canMove &#x3D; true;
		for(var i&#x3D;0; i&amp;lt;this.layers.length; i++){
			if(this.layers[i] &#x3D;&#x3D;&#x3D; this.activeLayer) continue;
			if(this.activeLayer.allowOverlap &amp;amp;&amp;amp; this.layers[i].allowOverlap) continue;
			if(this.doLayersOverlap(this.activeLayer, this.layers[i])){
				canMove &#x3D; false;
				break;
			}
		}
		
		this.activeLayer.x &#x3D; x;
		this.activeLayer.y &#x3D; y;
		
		return canMove;
	}
	
	/**
	 * Returns true if the active layer can be resized to the specified dimensions.
	 * @ignore
	 */
	canResizeActiveLayer(width, height){
		const inBounds &#x3D; this.isNewPosInBounds(this.activeLayer, this.activeLayer.x, this.activeLayer.y, width, height);
		if(this.activeLayer.forceBoundary &amp;amp;&amp;amp; !inBounds) return false;
		
		var w &#x3D; this.activeLayer.width;
		var h &#x3D; this.activeLayer.height;
		this.activeLayer.width &#x3D; w;
		this.activeLayer.height &#x3D; h;
		
		var canResize &#x3D; true;
		for(var i&#x3D;0; i&amp;lt;this.layers.length; i++){
			if(this.layers[i] &#x3D;&#x3D;&#x3D; this.activeLayer) continue;
			if(this.activeLayer.allowOverlap &amp;amp;&amp;amp; this.layers[i].allowOverlap) continue;
			if(this.doLayersOverlap(this.activeLayer, this.layers[i])){
				canResize &#x3D; false;
				break;
			}
		}
		
		this.activeLayer.width &#x3D; w;
		this.activeLayer.height &#x3D; h;
		
		return canResize;
	}
	
	/**
	 * Returns true if the active layer can be rotated to the specified degree.
	 * @ignore
	 */
	canRotateActiveLayer(degrees){
		var r &#x3D; this.activeLayer.rotation;
		this.activeLayer.rotation &#x3D; degrees;
		
		const inBounds &#x3D; this.isNewPosInBounds(this.activeLayer, this.activeLayer.x, this.activeLayer.y, this.activeLayer.width, this.activeLayer.height);
		if(this.activeLayer.forceBoundary &amp;amp;&amp;amp; !inBounds) return false;
		
		var canRotate &#x3D; true;
		for(var i&#x3D;0; i&amp;lt;this.layers.length; i++){
			if(this.layers[i] &#x3D;&#x3D;&#x3D; this.activeLayer) continue;
			if(this.activeLayer.allowOverlap &amp;amp;&amp;amp; this.layers[i].allowOverlap) continue;
			if(this.doLayersOverlap(this.activeLayer, this.layers[i])){
				canRotate &#x3D; false;
				break;
			}
		}
		
		this.activeLayer.rotation &#x3D; r;
		
		return canRotate;
	}
	
	/**
	 * Handle mouse moves over the canvas.
	 * @ignore
	 */
	onmousemove(e){
		var {x, y} &#x3D; this.canvasMousePos(e);
		this.setCursor(x, y);
		if(this.activeLayer &#x3D;&#x3D;&#x3D; null) return;
		
		if(this.rotatingActiveLayer){
			
			var dx &#x3D; x - this.activeLayer.x;
			var dy &#x3D; y - this.activeLayer.y;
			var angle &#x3D; Math.atan2(dy, dx);
			var degrees &#x3D; angle * 180 / Math.PI;
			
			if(!this.canRotateActiveLayer(degrees)){
				this.rotatingActiveLayer &#x3D; false;
				this.draw();
				return;
			}
			
			if(this.fireEvent(&#x27;layer-rotate&#x27;)){
				this.activeLayer.rotation &#x3D; degrees;
				if(this.activeLayer instanceof CanvasLayerGroup){
					this.activeLayer.updateLayers();
				}
				this.draw();
			}
		}else if(this.draggingActiveLayer){
			const newx &#x3D; this.activeLayerMouseOffset.x + x;
			const newy &#x3D; this.activeLayerMouseOffset.y + y;
			
			if(!this.canMoveActiveLayer(newx, newy)){
				this.draggingActiveLayer &#x3D; false;
				this.draw();
				return;
			}
			
			if(this.fireEvent(&#x27;layer-drag&#x27;)){
				
				var moveRightPixels &#x3D; newx - this.activeLayer.x;
				var moveDownPixels &#x3D; newy - this.activeLayer.y;
				
				this.activeLayer.x +&#x3D; moveRightPixels;
				this.activeLayer.y +&#x3D; moveDownPixels;
				
				if(this.activeLayer instanceof CanvasLayerGroup){
					this.activeLayer.updateLayers();
				}
				
				this.draw();
			}
		}else if(this.resizingActiveLayer){
			
			const {width, height} &#x3D; this.calculateLayerResize(x, y);
			if(!this.canResizeActiveLayer(width, height)){
				this.draggingActiveLayer &#x3D; false;
				this.draw();
				return;
			}
			
			if(this.fireEvent(&#x27;layer-resize&#x27;)){
				this.activeLayer.width &#x3D; width;
				this.activeLayer.height &#x3D; height;
				
				if(this.activeLayer instanceof CanvasLayerGroup){
					this.activeLayer.updateLayers();
				}
				
				this.draw();
			}
		}
	}
	
	/**
	 * Set the appropriate cursor.
	 * @ignore
	 */
	setCursor(x, y){
		if(this.rotatingActiveLayer){
			document.body.style.cursor &#x3D; this.cursors.rotating;
		}else if(this.draggingActiveLayer){
			document.body.style.cursor &#x3D; this.cursors.grabbing;
		}else if(this.resizingActiveLayer){
			document.body.style.cursor &#x3D; this.cursors.move;
		}else if(this.isNearActiveCorner(x, y)){
			document.body.style.cursor &#x3D; this.cursors.move;
		}else if(this.isNearActiveRotatePoint(x, y)){
			document.body.style.cursor &#x3D; this.cursors.rotate;
		}else if(this.isOverSelectableLayer(x, y)){
			document.body.style.cursor &#x3D; this.cursors.grab;
		}else{
			document.body.style.cursor &#x3D; this.cursors.default;
		}
	}
	
	/**
	 * Calculate new width and height of resizing image
	 * @ignore
	 */
	calculateLayerResize(x, y){
		var width &#x3D; this.activeLayer.width;
		var height &#x3D; this.activeLayer.height;
		
		var o &#x3D; this.lastMouseDownOffset;
		var n &#x3D; Canvas.layerRelativePoint(x, y, this.activeLayer);
		if(o.x &gt; 0){
			width &#x3D; Math.abs(this.activeLayerOriginalDimensions.width - (o.x-n.x)*2);
		}else{
			width &#x3D; Math.abs(this.activeLayerOriginalDimensions.width - (n.x-o.x)*2);
		}
		if(o.y &gt; 0){
			height &#x3D; Math.abs(this.activeLayerOriginalDimensions.height - (o.y-n.y)*2);
		}else{
			height &#x3D; Math.abs(this.activeLayerOriginalDimensions.height - (n.y-o.y)*2);
		}
		if(this.shiftKeyDown){
			var ratio &#x3D; Math.min(
				width/this.activeLayerOriginalDimensions.width, 
				height/this.activeLayerOriginalDimensions.height
			);
			width &#x3D; this.activeLayerOriginalDimensions.width * ratio;
			height &#x3D; this.activeLayerOriginalDimensions.height * ratio;
		}
		
		return {width, height};
	}
	
	/**
	 * Fire an event.
	 * @ignore
	 */
	fireEvent(type){
		var event &#x3D; new CustomEvent(type, {detail: this, cancelable: true, bubbles: true});
		return this.canvas.dispatchEvent(event);
	}
	
	/**
	 * Listen for click event on a layer
	 * @ignore
	 */
	onclick(e){
		var {x, y} &#x3D; this.canvasMousePos(e);
		var lcl &#x3D; this.getLayerAt(x, y);
		if(lcl){
			this.last_clicked_layer &#x3D; lcl;
			this.fireEvent(&#x27;layer-click&#x27;);
		}
	}
	
	/**
	 * Listen for dbl click event on a layer
	 * @ignore
	 */
	ondblclick(e){
		var {x, y} &#x3D; this.canvasMousePos(e);
		var lcl &#x3D; this.getLayerAt(x, y);
		if(lcl){
			this.last_clicked_layer &#x3D; lcl;
			this.fireEvent(&#x27;layer-dblclick&#x27;);
		}
	}
	
	/**
	 * Handle mousedown over the canvas.
	 * @ignore
	 */
	async onmousedown(e){
		var {x, y} &#x3D; this.canvasMousePos(e);
		this.setCursor(x, y);
		if(this.isNearActiveRotatePoint(x, y)){
			if(this.fireEvent(&#x27;layer-rotate-start&#x27;)){
				this.activeLayerRotateStartPos &#x3D; {x, y};
				this.rotatingActiveLayer &#x3D; true;
			}
		}else if(this.isNearActiveCorner(x, y)){
			if(this.fireEvent(&#x27;layer-resize-start&#x27;)){
				this.resizingActiveLayer &#x3D; true;
			}
		}else{
			var cancelled &#x3D; false;
			var layer &#x3D; this.getLayerAt(x, y);
			if(layer !&#x3D;&#x3D; null &amp;amp;&amp;amp; layer.selectable &#x3D;&#x3D;&#x3D; false) layer &#x3D; null;
			if(layer !&#x3D;&#x3D; null &amp;amp;&amp;amp; this.activeLayer !&#x3D;&#x3D; null &amp;amp;&amp;amp; layer !&#x3D;&#x3D; this.activeLayer){
				cancelled &#x3D; !this.fireEvent(&#x27;layer-deselect&#x27;);
				if(!cancelled) !this.deSelectLayer();
			}
			if(!cancelled &amp;amp;&amp;amp; layer !&#x3D;&#x3D; null &amp;amp;&amp;amp; this.fireEvent(&#x27;layer-drag-start&#x27;)){
				this.activeLayerMouseOffset.x &#x3D; layer.x - x;
				this.activeLayerMouseOffset.y &#x3D; layer.y - y;
				if(layer.draggable) this.draggingActiveLayer &#x3D; true;
				if(layer !&#x3D;&#x3D; this.activeLayer){
					if(this.fireEvent(&#x27;layer-select&#x27;)){
						this.selectLayer(layer);
					}
				}
			}
		}
		if(this.activeLayer){
			this.activeLayerOriginalDimensions &#x3D; {
				width: this.activeLayer.width,
				height: this.activeLayer.height
			};
			this.lastMouseDownOffset &#x3D; Canvas.layerRelativePoint(x, y, this.activeLayer);
		}
		
		// Handling the grouping 
		var layer &#x3D; this.getLayerAt(x, y);
		if(layer &amp;amp;&amp;amp; layer !&#x3D;&#x3D; this.ctrlGroupLayer &amp;amp;&amp;amp; layer.selectable){
			if(!this.isCtrlPressed) this.destroyCtrlGroup();	
			if(!this.isLayerInGroup(layer)){
				this.muteStateChanges &#x3D; true;
				await this.ctrlGroupLayer.addLayer(layer);
				if(this.ctrlGroupLayer.layers.length &#x3D;&#x3D;&#x3D; 1) this.selectLayer(layer);
				layer.onload(()&#x3D;&gt;{
					this.muteStateChanges &#x3D; false;
				});
			}
			if(!this.isGroupOnCanvas() &amp;amp;&amp;amp; this.ctrlGroupLayer.layers.length &gt; 1){
				this.muteStateChanges &#x3D; true;
				this.ctrlGroupLayer.layers.forEach(l&#x3D;&gt;{
					this.removeLayer(l);
				});
				this.addLayer(this.ctrlGroupLayer);
				this.ctrlGroupLayer.onload(()&#x3D;&gt;{
					this.muteStateChanges &#x3D; false;
				});
			}
			if(this.isGroupOnCanvas()){
				this.selectLayer(this.ctrlGroupLayer);
			}
		}
		
	}
	
	/**
	 * Are teh given coordinates near an active rotate anchor.
	 * @ignore
	 */
	isNearActiveRotatePoint(x, y){
		if(!this.activeLayer || !this.activeLayer.rotateable) return false;
		var {x, y} &#x3D; Canvas.layerRelativePoint(x, y, this.activeLayer);
		var mx &#x3D; (this.activeLayer.width/2)+25;
		var my &#x3D; 0;
		var dist &#x3D; Math.hypot(mx-x, my-y);
		if(dist &amp;lt;&#x3D; this.getScale() * this.anchorRadius) return true;
		return false;
	}
	
	/**
	 * Are the given coordinates near an active resize anchor.
	 * @ignore
	 */
	isNearActiveCorner(x, y){
		if(!this.activeLayer || !this.activeLayer.resizable) return false;
		var {x, y} &#x3D; Canvas.layerRelativePoint(x, y, this.activeLayer);
		var isNear &#x3D; false;
		this.activeLayer.getCorners().forEach(corner&#x3D;&gt;{			
			var dist &#x3D; Math.hypot(corner.x-x, corner.y-y);
			if(dist &amp;lt;&#x3D; this.getScale() * this.anchorRadius) isNear &#x3D; true;
		});
		return isNear;
	}
	
	/**
	 * Given a position, check if it is in bounds
	 * @ignore
	 */
	isNewPosInBounds(layer, x, y, width, height){
		var _x &#x3D; layer.x;
		var _y &#x3D; layer.y;
		var _width &#x3D; layer.width;
		var _height &#x3D; layer.height;
		
		layer.x &#x3D; x;
		layer.y &#x3D; y;
		layer.width &#x3D; width;
		layer.height &#x3D; height;
		
		var inbounds &#x3D; true;
		layer.getCorners().forEach(corner &#x3D;&gt; {
			var pos &#x3D; Canvas.absolutePoint(corner.x, corner.y, layer.x, layer.y, layer.rotation);
			if (pos.x &amp;lt; 0 || pos.x &gt; this.width || pos.y &amp;lt; 0 || pos.y &gt; this.width) {
				inbounds &#x3D; false;
			}
		});
		layer.x &#x3D; _x;
		layer.y &#x3D; _y;
		layer.width &#x3D; _width;
		layer.height &#x3D; _height;
		return inbounds;
	}
	
	/**
	 * Get nearest grid line
	 * @ignore
	 */
	getNearestGridline(n, grid){
		return Object.values(grid.reduce((acc, val)&#x3D;&gt;{
			if(val &gt; n){
				if(null &#x3D;&#x3D;&#x3D; acc.high) acc.high &#x3D; val;
				else acc.high &#x3D; Math.min(acc.high, val);
			}else{
				if(null &#x3D;&#x3D;&#x3D; acc.low) acc.low &#x3D; val;
				else acc.low &#x3D; Math.max(acc.low, val);
			}
			return acc;
		}, {low: null, high: null})).reduce((acc, val)&#x3D;&gt;{
			var valDistToN &#x3D; Math.abs(val - n);
			var accDistToN &#x3D; acc &#x3D;&#x3D;&#x3D; null ? null : Math.abs(acc - n);
			if(acc &#x3D;&#x3D;&#x3D; null || valDistToN &amp;lt; accDistToN) acc &#x3D; val;
			return acc;
		}, null);
	}
	
	/**
	 * Handle mouseup or mouseout.
	 * @ignore
	 */
	onmousereset(e){
		if(this.draggingActiveLayer) this.fireEvent(&quot;layer-drag-end&quot;);
		if(this.resizingActiveLayer) this.fireEvent(&quot;layer-resize-end&quot;);
		if(this.rotatingActiveLayer) this.fireEvent(&quot;layer-rotate-end&quot;);
		
		if(this.draggingActiveLayer &amp;amp;&amp;amp; this.snapToGrid &amp;amp;&amp;amp; this.activeLayer){
			var {xs, ys} &#x3D; this.getGridLines();
			var closestx &#x3D; this.getNearestGridline(this.activeLayer.x, xs);
			var closesty &#x3D; this.getNearestGridline(this.activeLayer.y, ys);
			var redraw_required &#x3D; false;
			var dist &#x3D; Math.abs(closestx - this.activeLayer.x);
			if(dist &amp;lt;&#x3D; this.gridDistancePixels &amp;amp;&amp;amp; dist !&#x3D;&#x3D; 0){
				this.activeLayer.x &#x3D; closestx;
				redraw_required &#x3D; true;
			}
			dist &#x3D; Math.abs(closesty - this.activeLayer.y);
			if(dist &amp;lt;&#x3D; this.gridDistancePixels &amp;amp;&amp;amp; dist !&#x3D;&#x3D; 0){
				this.activeLayer.y &#x3D; closesty;
				redraw_required &#x3D; true;
			}
			if(redraw_required){
				this.draw();
			}
		}
		if(this.draggingActiveLayer || this.resizingActiveLayer || this.rotatingActiveLayer) this.saveState();
		var {x, y} &#x3D; this.canvasMousePos(e);
		this.draggingActiveLayer &#x3D; false;
		this.resizingActiveLayer &#x3D; false;
		this.rotatingActiveLayer &#x3D; false;
		this.lastMouseDownOffset &#x3D; {x:0, y:0};
		this.activeLayerMouseOffset &#x3D; {x:0, y:0};
		this.activeLayerOriginalDimensions &#x3D; {width:0, height:0};
		this.activeLayerRotateStartPos &#x3D; {x:0, y:0};
		this.setCursor(x, y);
	}
	
	/**
	 * Get the scale of the canvas
	 * @ignore
	 */
	getScale(){
		var rect &#x3D; this.canvas.getBoundingClientRect();
		return this.canvas.width / rect.width;
	}
	
}

/**
 * The version of the library
 * @type {String}
 */
Canvas.version &#x3D; &#x27;2.0.1&#x27;;

/**
 * The default anchorRadius value for all Canvas instances.
 * @type {Number}
 */
Canvas.anchorRadius &#x3D; 8;

/**
 * The default strokeStyle value for all Canvas instances.
 * @type {String}
 */
Canvas.strokeStyle &#x3D; &#x27;#ba0000&#x27;;

/**
 * The default fillStyle value for all Canvas instances.
 * @type {String}
 */
Canvas.fillStyle &#x3D; &#x27;black&#x27;;

/**
 * The default lineWidth value for all Canvas instances.
 * @type {Number}
 */
Canvas.lineWidth &#x3D; 5;

/**
 * The default Cursor values for all Canvas instances. See the canvas constructor for details.
 * @type {Object}
 * @property {String} Canvas.cursors.default
 * @property {String} Canvas.cursors.grab
 * @property {String} Canvas.cursors.grabbing
 * @property {String} Canvas.cursors.move
 * @property {String} Canvas.cursors.rotate
 * @property {String} Canvas.cursors.rotating
 */
Canvas.cursors &#x3D; {
	default: null,
	grab: &quot;grab&quot;,
	grabbing: &quot;grabbing&quot;,
	move: &quot;crosshair&quot;,
	rotate: &quot;grab&quot;,
	rotating: &quot;grabbing&quot;
};


/**
 * Convert a relative point to an absolute point.
 * @ignore
 */
Canvas.absolutePoint &#x3D; (relPointX, relPointY, centerX, centerY, rotationDegrees) &#x3D;&gt; {
   var radians &#x3D; rotationDegrees * (Math.PI / 180);
   var cos &#x3D; Math.cos(radians);
   var sin &#x3D; Math.sin(radians);
   var x &#x3D; centerX + (relPointX * cos) - (relPointY * sin);
   var y &#x3D; centerY + (relPointX * sin) + (relPointY * cos);
   return {x, y};
};

/**
 * Get the position of a point relative to another point and possibly rotated.
 * @ignore
 */
Canvas.relativePoint &#x3D; (absPointX, absPointY, centerX, centerY, rotation) &#x3D;&gt; {
   absPointX -&#x3D; centerX;
   absPointY -&#x3D; centerY;
   var radians &#x3D; rotation * (Math.PI / 180);
   var cos &#x3D; Math.cos(radians);
   var sin &#x3D; Math.sin(radians);
   var x &#x3D; (absPointX * cos) + (absPointY * sin);
   var y &#x3D; (-absPointX * sin) + (absPointY * cos);
   x &#x3D; Math.floor(x * 100) / 100;
   y &#x3D; Math.floor(y * 100) / 100;
   return {x, y};
};

/**
 * Get the point relative to the center of a given layer.
 * @ignore
 */
Canvas.layerRelativePoint &#x3D; (absPointX, absPointY, layer) &#x3D;&gt; {
   return Canvas.relativePoint(absPointX, absPointY, layer.x, layer.y, layer.rotation);
};

/**
 * Are the given coordinates over the given layer?
 * @param {Number} x - The x ordinate.
 * @param {Number} y - The y ordinate.
 * @param {CanvasLayer} layer - The layer to check.
 * @returns {Boolean}
 */
Canvas.isOverLayer &#x3D; (x, y, layer) &#x3D;&gt; {
	let r &#x3D; Canvas.layerRelativePoint(x, y, layer);
	if(r.x &gt; (layer.width/2)) return false;
	if(r.x &amp;lt; -(layer.width/2)) return false;
	if(r.y &gt; (layer.height/2)) return false;
	if(r.y &amp;lt; -(layer.height/2)) return false;
	return true;
};

/**
 * returns true if the line from (a,b)-&gt;(c,d) intersects with (p,q)-&gt;(r,s)
 * @url https://stackoverflow.com/questions/9043805/test-if-two-lines-intersect-javascript-function
 * @returns {Boolean}
 */
Canvas.doLinesIntersect &#x3D; (a,b,c,d,p,q,r,s) &#x3D;&gt; {
	var det, gamma, lambda;
	det &#x3D; (c - a) * (s - q) - (r - p) * (d - b);
	if (det &#x3D;&#x3D;&#x3D; 0) {
		return false;
	} else {
		lambda &#x3D; ((s - q) * (r - a) + (p - r) * (s - b)) / det;
		gamma &#x3D; ((b - d) * (r - a) + (c - a) * (s - b)) / det;
		return (0 &amp;lt; lambda &amp;amp;&amp;amp; lambda &amp;lt; 1) &amp;amp;&amp;amp; (0 &amp;lt; gamma &amp;amp;&amp;amp; gamma &amp;lt; 1);
	}
};

/**
 * Class representing the layers drawn on the canvas.
 */
class CanvasLayer{
	
	/**
	 * Create a new Layer.
	 * @param {String} url - The URL or URI of an image to draw on the canvas.
	 * @param {String} name - The name of the layer.
	 * @param {Number} x - The x position of the layer on the canvas.
	 * @param {Number} y - The y position of the layer on the canvas.
	 * @param {Number} [width&#x3D;null] - The width of the layer on the canvas.
	 * @param {Number} [height&#x3D;null] - The height of the layer on the canvas.
	 * @param {Number} [rotation&#x3D;0] - The rotation of the layer on the canvas.
	 * @param {Boolean} [draggable&#x3D;true] - Is the layer draggable?
	 * @param {Boolean} [rotateable&#x3D;true] - Is the layer rotateable?
	 * @param {Boolean} [resizable&#x3D;true] - Is the layer resizable?
	 * @param {Boolean} [selectable&#x3D;true] - Is the layer selectable?
	 * @param {Boolean} [forceBoundary&#x3D;false] - Force the layer to stay in bounds?
	 * @param {Boolean} [opts.allowOverlap&#x3D;true] - Allow layers to overlap with this one.
	 * @returns {CanvasLayer}
	 */
	constructor(url, name, x, y, width&#x3D;null, height&#x3D;null, rotation&#x3D;0, draggable&#x3D;true, rotateable&#x3D;true, resizable&#x3D;true, selectable&#x3D;true, forceBoundary&#x3D;false, allowOverlap&#x3D;true){
		this.name &#x3D; name;
		this.url &#x3D; url;
		this.ready &#x3D; false;
		this.image &#x3D; null;
		this.x &#x3D; x;
		this.y &#x3D; y;
		this.width &#x3D; width;
		this.height &#x3D; height;
		this.rotation &#x3D; rotation;
		this.draggable &#x3D; draggable;
		this.rotateable &#x3D; rotateable;
		this.resizable &#x3D; resizable;
		this.selectable &#x3D; selectable;
		this.forceBoundary &#x3D; forceBoundary;
		this.allowOverlap &#x3D; allowOverlap;
		this.load_cb_stack &#x3D; [];
		
		this.xoffset &#x3D; 0;
		this.yoffset &#x3D; 0;
		this.roffset &#x3D; 0;
		this.owidth &#x3D; 0;
		this.oheight &#x3D; 0;
		
		this.load();
	}
	
	/**
	 * jsonify the current layer
	 * @returns {String} - Serialized layer
	 */
	objectify(){
		return {
			layer: this, 
			state: {
				name: this.name,
				url: this.url,
				x: this.x,
				y: this.y,
				width: this.width,
				height: this.height,
				rotation: this.rotation,
				draggable: this.draggable,
				rotatable: this.rotateable,
				resizable: this.resizable,
				selectable: this.selectable,
				forceBoundary: this.forceBoundary
			}
		};
	}
	
	/**
	 * Register a function to be called when the layer is fully loaded.
	 * @param {Function} fn - The callback function.
	 * @returns {undefined}
	 */
	onload(fn){
		if(this.ready){
			fn();
			return;
		}else{
			this.load_cb_stack.push(fn);
		}
	}
	
	/**
	 * Load the layer so it is ready to use.
	 * @returns {Promise} - A promise that resolves when the layer is ready
	 */
	load(){
		return new Promise(done&#x3D;&gt;{
			if(this.ready){
				done();
			}else{
				const img &#x3D; new Image();
				img.onload &#x3D; ()&#x3D;&gt;{
					this.image &#x3D; img;
					if(this.width&#x3D;&#x3D;&#x3D;null) this.width &#x3D; img.width;
					if(this.height&#x3D;&#x3D;&#x3D;null) this.height &#x3D; img.height;
					this.ready &#x3D; true;
					this.load_cb_stack.forEach(fn&#x3D;&gt;fn());
					this.load_cb_stack &#x3D; [];
					done();
				};
				img.src &#x3D; this.url;
			}
		});
	}
	
	/**
	 * Get the relative position of all the corners.
	 * @ignore
	 */
	getCorners(){
		return [
			{x:-(this.width/2), y:-(this.height/2)},
			{x:-(this.width/2)+this.width, y:-(this.height/2)},
			{x:-(this.width/2)+this.width, y:-(this.height/2)+this.height},
			{x:-(this.width/2), y:-(this.height/2)+this.height}
		];
	}
	
}

/**
 * un Serialize a layer
 * @param {type} str
 * @returns {CanvasLayer}
 */
CanvasLayer.deobjectify &#x3D; function(d){
	var layer &#x3D; d.layer;
	Object.keys(d.state).forEach(key&#x3D;&gt;{
		layer[key] &#x3D; d.state[key];
	});
	return layer;
};

/**
 * CavnasLayer that controls multiple layers
 */
class CanvasLayerGroup extends CanvasLayer{
	
	/**
	 * Create a new Layer.
	 * @param {String} name - The name of the layer.
	 * @param {Boolean} [draggable&#x3D;true] - Is the layer draggable?
	 * @param {Boolean} [rotateable&#x3D;true] - Is the layer rotateable?
	 * @param {Boolean} [resizable&#x3D;true] - Is the layer resizable?
	 * @param {Boolean} [selectable&#x3D;true] - Is the layer selectable?
	 * @param {Boolean} [forceBoundary&#x3D;false] - Force the layer to stay in bounds?
	 * @returns {CanvasLayerGroup}
	 */
	constructor(name, draggable&#x3D;true, rotateable&#x3D;true, resizable&#x3D;true, selectable&#x3D;true, forceBoundary&#x3D;false){
		var url &#x3D; &#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/1+yHgAHtAKYD9BncgAAAABJRU5ErkJggg&#x3D;&#x3D;&#x27;;
		super(url, name, 0, 0, 1, 1, 0, draggable, rotateable, resizable, selectable, forceBoundary);
		this.layers &#x3D; [];
	}
	
	/**
	 * Get the layer on the given canvas at the given position. If this group 
	 * is selected it will return the layer in this group at the given 
	 * position, if applicatble.
	 * @param {Canvas} canvas - The Canvas element that owns the layers.
	 * @param {Number} x - The x position of the mouseclick relative to the canvas.
	 * @param {Number} y - The y position of the mouseclick relative to the canvas.
	 * @returns {layer|null}
	 */
	getLayerOrSubLayerAt(canvas, x, y){
		for(let i&#x3D;0; i&amp;lt;canvas.layers.length; i++){
			
			let layer &#x3D; canvas.layers[i];
			
			if(layer &#x3D;&#x3D;&#x3D; this){
				for(let i&#x3D;this.layers.length; i--;){
					let layer &#x3D; this.layers[i];
					if(Canvas.isOverLayer(x, y, layer)) return layer;
				}
			}
			
			if(Canvas.isOverLayer(x, y, layer)) return layer;
		}
		return null;
	}
	
	/**
	 * Remove the provided layer from the group.
	 * @param {CanvasLayer} layer - The layer to remove.
	 * @returns {Promise}
	 */
	async removeLayer(layer){
		delete layer.xoffset;
		delete layer.yoffset;
		this.layers.splice(this.layers.indexOf(layer), 1);
		return await this.regenerate();
	}
	
	/**
	 * Add a layer to the group
	 * @param {CanvasLayer} layer - The layer to add.
	 * @returns {Promise}
	 */
	async addLayer(layer){
		if(layer &#x3D;&#x3D;&#x3D; this) return;
		if(layer instanceof CanvasLayerGroup){
			this.layers.push(...layer.layers);
		}else{			
			this.layers.push(layer);
		}
		return await this.regenerate();
	}
	
	/**
	 * Regenerate images and dimensions.
	 * @ignore
	 */
	async regenerate(){
		var params &#x3D; await this.getParams();
		
		this.width &#x3D; this.owidth &#x3D; params.width;
		this.height &#x3D; this.oheight &#x3D; params.height;
		
		this.x &#x3D; params.x;
		this.y &#x3D; params.y;
		this.rotation &#x3D; 0;
		
		this.forceBoundary &#x3D; params.forceBoundary;
		this.draggable &#x3D;  params.draggable;
		this.rotateable &#x3D;  params.rotateable;
		this.resizable &#x3D;  params.resizable;
		this.selectable &#x3D; params.selectable;
		
		this.url &#x3D; params.uri;
		this.ready &#x3D; false;
		return await this.load();
	}
	
	/**
	 * Update the sublayers of this group.
	 * @ignore
	 */
	updateLayers(){
		var ratiox &#x3D; this.width/this.owidth;
		var ratioy &#x3D; this.height/this.oheight;
		this.layers.forEach(layer&#x3D;&gt;{
			layer.width &#x3D; layer.owidth * ratiox;
			layer.height &#x3D; layer.oheight * ratioy;			
			layer.rotation &#x3D; layer.roffset + this.rotation;
			var pos &#x3D; Canvas.absolutePoint(layer.xoffset*ratiox, layer.yoffset*ratioy, this.x, this.y, this.rotation);
			layer.x &#x3D; pos.x;
			layer.y &#x3D; pos.y;
			
		});
	}
	
	/**
	 * Regenerate images and dimensions.
	 * @ignore
	 */
	async getParams(){
		const allCorners &#x3D; this.layers.map(layer &#x3D;&gt; {
			return layer.getCorners().map(corner&#x3D;&gt;{
				return Canvas.absolutePoint(corner.x, corner.y, layer.x, layer.y, layer.rotation);
			});
		});
		
		const allBounds &#x3D; [];
		allCorners.forEach(corners&#x3D;&gt;{
			allBounds.push(...corners);
		});

		var pos &#x3D; {
			left: allBounds.reduce((acc, cur)&#x3D;&gt;Math.min(acc, cur.x), Infinity),
			top: allBounds.reduce((acc, cur)&#x3D;&gt;Math.min(acc, cur.y), Infinity),
			right: allBounds.reduce((acc, cur)&#x3D;&gt;Math.max(acc, cur.x),0),
			bottom: allBounds.reduce((acc, cur)&#x3D;&gt;Math.max(acc, cur.y),0)
		};
		pos.width &#x3D; pos.right - pos.left;
		pos.height &#x3D; pos.bottom - pos.top;
		pos.x &#x3D; pos.left+(pos.width/2);
		pos.y &#x3D; pos.top+(pos.height/2);

		var ele &#x3D; document.createElement(&#x27;canvas&#x27;);
		ele.width &#x3D; pos.right+2;
		ele.height &#x3D; pos.bottom+2;
		var canvas &#x3D; new Canvas(ele);
		this.layers.forEach(layer&#x3D;&gt;canvas.addLayer(layer));
		
		pos.uri &#x3D; await canvas.extractPortion(pos.x, pos.y, pos.width, pos.height, 0, false);
		
		pos.forceBoundary &#x3D; this.layers.reduce((acc, itm)&#x3D;&gt;itm.forceBoundary||acc,false);
		pos.draggable &#x3D; this.layers.reduce((acc, itm)&#x3D;&gt;acc&#x3D;&#x3D;&#x3D;false?false:itm.draggable,true);
		pos.rotateable &#x3D; this.layers.reduce((acc, itm)&#x3D;&gt;acc&#x3D;&#x3D;&#x3D;false?false:itm.draggable,true);
		pos.resizable &#x3D; this.layers.reduce((acc, itm)&#x3D;&gt;acc&#x3D;&#x3D;&#x3D;false?false:itm.draggable,true);
		pos.selectable &#x3D; this.layers.reduce((acc, itm)&#x3D;&gt;acc&#x3D;&#x3D;&#x3D;false?false:itm.draggable,true);
		
		this.layers.forEach(l&#x3D;&gt;{
			l.xoffset &#x3D; l.x - pos.x;
			l.yoffset &#x3D; l.y - pos.y;
			l.roffset &#x3D; l.rotation;
			l.owidth &#x3D; l.width;
			l.oheight &#x3D; l.height;
		});
		
		return pos;
	}

}

/**
 * Extention class that provides drawing abilities
 */
class DrawingCanvas extends Canvas{
	
	/**
	 * Construct a new instance of the Canvas class
	 * @param {HTMLElement} canvas - The canvas to instantiate the class upon.
	 * @param {Number} [opts.anchorRadius&#x3D;Canvas.anchorRadius] - The radius of the anchor points shown on selected elements.
	 * @param {String} [opts.strokeStyle&#x3D;Canvas.strokeStyle] - The color of the outlines drawn on selceted elements. May be any valid CSS color string.
	 * @param {String} [opts.fillStyle&#x3D;Canvas.fillStyle] - The color of the anchor points shown on selected elements. May be any valid CSS color string.
	 * @param {Number} [opts.lineWidth&#x3D;Canvas.lineWidth] - The width of the outlines shown on selected elements.
	 * @param {String} [opts.cursors.default&#x3D;Canvas.cursors.default] - The default cursor to use when hovering over the canvas. May be any valid css cursor value.
	 * @param {String} [opts.cursors.grab&#x3D;Canvas.cursors.grab] - The grab cursor to use when hovering over a movable layer. May be any valid css cursor value.
	 * @param {String} [opts.cursors.grabbing&#x3D;Canvas.cursors.grabbing] - The grabbing cursor to use when dragging a layer. May be any valid css cursor value.
	 * @param {String} [opts.cursors.move&#x3D;Canvas.cursors.move] - The default cursor to use when hovering over a resize anchor. May be any valid css cursor value.
	 * @param {String} [opts.cursors.rotate&#x3D;Canvas.cursors.rotate] - The default cursor to use when hovering a rotate anchor point. May be any valid css cursor value.
	 * @param {String} [opts.cursors.rotating&#x3D;Canvas.cursors.rotating] - The default cursor to use when rotating an active layer. May be any valid css cursor value.
	 * @returns {Canvas}
	 */
	constructor(canvas, opts&#x3D;{}){
		super(canvas, opts);
		this.drawing_mode &#x3D; null;
		this.line_color &#x3D; &#x27;#000000&#x27;;
		this.fill_color &#x3D; &#x27;#0000FF&#x27;;
		this.shape_start_pos &#x3D; null;
		this.is_mouse_down &#x3D; false;
		this.freehand_coords &#x3D; [];
		this.rcanvas &#x3D; document.createElement(&#x27;canvas&#x27;);
		this.rcanvas.height &#x3D; this.height;
		this.rcanvas.width &#x3D; this.width;
		this.rctx &#x3D; this.rcanvas.getContext(&#x27;2d&#x27;);
		this.ccanvas &#x3D; document.createElement(&#x27;canvas&#x27;);
		this.cctx &#x3D; this.ccanvas.getContext(&#x27;2d&#x27;);
		this.drawing_layer &#x3D; null;
		this.layer_dimensions &#x3D; null;
	}
	
	/**
	 * Set the border or line width;
	 * @param {Number} width
	 * @returns {undefined}
	 */
	setLineWidth(width){
		this.rctx.lineWidth &#x3D; +width;
	}
	
	/**
	 * Set the CSS color style of the border or line
	 * @param {string} style
	 * @returns {undefined}
	 */
	setStrokeStyle(style){
		this.rctx.strokeStyle &#x3D; style;
	}
	
	/**
	 * Set the CSS color style background of the shape
	 * @param {string} style
	 * @returns {undefined}
	 */
	setFillStyle(style){
		this.rctx.fillStyle &#x3D; style;
	}
	
	////////////////////////////////////////////////////////////////////////////
	// Helpers /////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////
	
	/**
	 * @ignore
	 */
	drawEllipse(ctx, x, y, w, h) {
		var kappa &#x3D; .5522848,
			ox &#x3D; (w / 2) * kappa, // control point offset horizontal
			oy &#x3D; (h / 2) * kappa, // control point offset vertical
			xe &#x3D; x + w, // x-end
			ye &#x3D; y + h, // y-end
			xm &#x3D; x + w / 2, // x-middle
			ym &#x3D; y + h / 2; // y-middle

		ctx.save();
		ctx.beginPath();
		ctx.moveTo(x, ym);
		ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
		ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
		ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
		ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
		ctx.fill();
		ctx.stroke();
		ctx.restore();
	}
	
	/**
	 * @ignore
	 */
	renderLayer(){
		const {x, y, width, height} &#x3D; this.layer_dimensions;
		this.ccanvas.width &#x3D; width;
		this.ccanvas.height &#x3D; height;
		this.cctx.clearRect(0, 0, width, height);
		this.cctx.drawImage(this.rcanvas, x, y, width, height, 0, 0, width, height);
		var duri &#x3D; this.ccanvas.toDataURL();
		
		const xpos &#x3D; x + (width/2);
		const ypos &#x3D; y + (height/2);
		
		if(!this.drawing_layer){
			this.drawing_layer &#x3D; this.addLayer(duri, {xpos, ypos});
		}else{
			this.drawing_layer.x &#x3D; xpos;
			this.drawing_layer.y &#x3D; ypos;
			this.drawing_layer.width &#x3D; width;
			this.drawing_layer.height &#x3D; height;
			this.drawing_layer.url &#x3D; duri;
			this.drawing_layer.ready &#x3D; false;
			this.drawing_layer.image &#x3D; null;
			this.drawing_layer.load().then(()&#x3D;&gt;this.draw());
		}
	}
	
	/**
	 * @ignore
	 */
	recalculateLayerDimensions(newMousePos){
		var x, y, width, height;
		if(this.drawing_mode &#x3D;&#x3D;&#x3D; &#x27;freehand&#x27;){
			this.freehand_coords.push(newMousePos);
			var all_x &#x3D; this.freehand_coords.map(c&#x3D;&gt;c.x);
			var all_y &#x3D; this.freehand_coords.map(c&#x3D;&gt;c.y);
			x &#x3D; Math.min(...all_x);
			y &#x3D; Math.min(...all_y);
			var max_x &#x3D; Math.max(...all_x);
			var max_y &#x3D; Math.max(...all_y);
			width &#x3D; Math.max(0.1, Math.abs(x - max_x));
			height &#x3D; Math.max(0.1, Math.abs(y - max_y));
		}else{
			x &#x3D; Math.min(this.shape_start_pos.x, newMousePos.x);
			y &#x3D; Math.min(this.shape_start_pos.y, newMousePos.y);
			width &#x3D; Math.max(0.1, Math.abs(this.shape_start_pos.x - newMousePos.x));
			height &#x3D; Math.max(0.1, Math.abs(this.shape_start_pos.y - newMousePos.y));
		}
		this.layer_dimensions &#x3D; {x, y, width, height};
	}
	
	/**
	 * @ignore
	 */
	onmousemove(e){
		if(!this.drawing_mode) return super.onmousemove(e);
		if(!this.is_mouse_down) return;
		this.rctx.clearRect(0, 0, this.width, this.height);
		const pos &#x3D; this.canvasMousePos(e);
		this.recalculateLayerDimensions(pos);
		switch(this.drawing_mode){
			case &quot;rectangle&quot;:
				var {x, y, width, height} &#x3D; this.layer_dimensions;
				
				this.rctx.beginPath();
				this.rctx.rect(x, y, width, height);
				this.rctx.fill();
				this.rctx.stroke();
				
				this.renderLayer();
				
				break;
			case &quot;ellipse&quot;:
				var {x, y, width, height} &#x3D; this.layer_dimensions;
				this.drawEllipse(this.rctx, x, y, width, height);
				this.renderLayer();
				break;
			case &quot;line&quot;:
				var x1 &#x3D; this.shape_start_pos.x, 
					y1 &#x3D; this.shape_start_pos.y, 
					x2 &#x3D; pos.x, 
					y2 &#x3D; pos.y;
				this.rctx.beginPath();
				this.rctx.moveTo(x1, y1);
				this.rctx.lineTo(x2, y2);
				this.rctx.fill();
				this.rctx.stroke(); 
				this.renderLayer();
				break;
			case &quot;freehand&quot;:
				if(this.freehand_coords &amp;lt; 2) break;
				var a &#x3D; this.freehand_coords[0];
				for(var i&#x3D;1; i&amp;lt;this.freehand_coords.length; i++){
					this.rctx.beginPath();
					this.rctx.moveTo(a.x, a.y);
					this.rctx.lineTo(this.freehand_coords[i].x, this.freehand_coords[i].y);
					this.rctx.fill();
					this.rctx.stroke(); 
					a &#x3D; this.freehand_coords[i];
				}
				this.renderLayer();
				break;
		}
	}
	
	/**
	 * @ignore
	 */
	onmousedown(e){
		if(!this.drawing_mode) return super.onmousedown(e);
		this.is_mouse_down &#x3D; true;
		this.shape_start_pos &#x3D; this.canvasMousePos(e);
	}
	
	/**
	 * @ignore
	 */
	onmousereset(e){
		if(!this.drawing_mode) return super.onmousereset(e);
		this.is_mouse_down &#x3D; false;
		this.shape_start_pos &#x3D; null;
		this.drawing_layer &#x3D; null;
		this.layer_dimensions &#x3D; null;
		this.freehand_coords &#x3D; [];
	}
	
}

class CanvasFonts{}

CanvasFonts.getNative &#x3D; async (force_recheck &#x3D; false) &#x3D;&gt; {
	
	if(CanvasFonts._native_available.length &amp;amp;&amp;amp; !force_recheck){
		return CanvasFonts._native_available;
	}

	var _native_available &#x3D; [];
	await document.fonts.ready;
	CanvasFonts._native_fontlist.forEach(font &#x3D;&gt; {
		if (document.fonts.check(&#x60;12px &quot;${font}&quot;&#x60;)) {
			_native_available.push(font);
		}
	})

	CanvasFonts._native_available &#x3D; [...new Set(_native_available)].sort();
	return CanvasFonts._native_available;
};

CanvasFonts.getDownloaded &#x3D; async (force_recheck &#x3D; false) &#x3D;&gt; {
	if(CanvasFonts._downloaded_available.length &amp;amp;&amp;amp; !force_recheck){
		return CanvasFonts._downloaded_available;
	}
	
	let {fonts} &#x3D; document;
	const it &#x3D; fonts.entries();

	let arr &#x3D; [];
	let done &#x3D; false;

	while (!done) {
		const font &#x3D; it.next();
		if (!font.done) {
			
			var family;
			try{
				family &#x3D; JSON.parse(font.value[0].family);
			}catch(e){
				family &#x3D; font.value[0].family;
			}
			
			arr.push(family);
		} else {
			done &#x3D; font.done;
		}
	}
	
	CanvasFonts._downloaded_available &#x3D; [...new Set(arr)].sort();
	return CanvasFonts._downloaded_available;
};

CanvasFonts.getAvailable &#x3D; async () &#x3D;&gt; {
	var native &#x3D; await CanvasFonts.getNative();
	var downloaded &#x3D; await CanvasFonts.getDownloaded();
	return [...new Set([...native, ...downloaded])].sort();
};

CanvasFonts._native_available &#x3D; [];
CanvasFonts._downloaded_available &#x3D; [];
CanvasFonts._native_fontlist &#x3D; [
	&#x27;Arial&#x27;,
	&#x27;Arial Unicode MS&#x27;,
	&#x27;Bitstream Cyberbit&#x27;,
	&#x27;BitstreamCyberCJK&#x27;,
	&#x27;Brampton&#x27;,
	&#x27;Cardo&#x27;,
	&#x27;Caslon Roman&#x27;,
	&#x27;Charis SIL&#x27;,
	&#x27;Chrysanthi Unicode&#x27;,
	&#x27;Chryſanþi Unicode&#x27;,
	&#x27;ClearlyU&#x27;,
	&#x27;Code2000&#x27;,
	&#x27;DejaVu Sans&#x27;,
	&#x27;Doulos SIL&#x27;,
	&#x27;Everson Mono&#x27;,
	&#x27;Gentium Regular&#x27;,
	&#x27;Gentium Plus&#x27;,
	&#x27;GNU FreeFont&#x27;,
	&#x27;Unifont&#x27;,
	&#x27;GNU Unifont&#x27;,
	&#x27;HAN NOM A&#x27;,
	&#x27;HAN NOM B&#x27;,
	&#x27;Horta&#x27;,
	&#x27;Junicode&#x27;,
	&#x27;Kelvinch&#x27;,
	&#x27;Linux Libertine&#x27;,
	&#x27;Lucida Grande&#x27;,
	&#x27;Lucida Sans Unicode&#x27;,
	&#x27;Microsoft JhengHei&#x27;,
	&#x27;Microsoft Sans Serif&#x27;,
	&#x27;New Gulim&#x27;,
	&#x27;Noto&#x27;,
	&#x27;PragmataPro&#x27;,
	&#x27;Quivira&#x27;,
	&#x27;Segoe UI Regular&#x27;,
	&#x27;Squarish Sans CT&#x27;,
	&#x27;STIX&#x27;,
	&#x27;Sun-ExtA&#x27;,
	&#x27;Sun-ExtB&#x27;,
	&#x27;Tahoma&#x27;,
	&#x27;Times New Roman&#x27;,
	&#x27;TITUS Cyberbit Basic&#x27;,
	&#x27;WenQuanYi Bitmap Song&#x27;,
	&#x27;WenQuanYi Micro Hei&#x27;,
	&#x27;WenQuanYi Zen Hei&#x27;,
	&#x27;Y.OzFontN&#x27;,
	&#x27;XITS&#x27;,
	&#x27;Aharoni&#x27;,
	&#x27;Aldhabi&#x27;,
	&#x27;Andalus&#x27;,
	&#x27;Angsana New&#x27;,
	&#x27;AngsanaUPC&#x27;,
	&#x27;Aparajita&#x27;,
	&#x27;Arabic Typesetting&#x27;,
	&#x27;Bahnschrift&#x27;,
	&#x27;Batang&#x27;,
	&#x27;BatangChe&#x27;,
	&#x27;BIZ UDGothic&#x27;,
	&#x27;BIZ UDPGothic&#x27;,
	&#x27;BIZ UDMincho&#x27;,
	&#x27;BIZ UDPMincho&#x27;,
	&#x27;Book Antiqua&#x27;,
	&#x27;Browallia New&#x27;,
	&#x27;BrowalliaUPC&#x27;,
	&#x27;Calibri&#x27;,
	&#x27;Calisto MT&#x27;,
	&#x27;Cambria&#x27;,
	&#x27;Cambria Math&#x27;,
	&#x27;Candara&#x27;,
	&#x27;Century Gothic&#x27;,
	&#x27;Comic Sans MS&#x27;,
	&#x27;Consolas&#x27;,
	&#x27;Constantia&#x27;,
	&#x27;Copperplate Gothic&#x27;,
	&#x27;Corbel&#x27;,
	&#x27;Cordia New&#x27;,
	&#x27;CordiaUPC&#x27;,
	&#x27;Courier New&#x27;,
	&#x27;DaunPenh&#x27;,
	&#x27;David&#x27;,
	&#x27;DengXian&#x27;,
	&#x27;DilleniaUPC&#x27;,
	&#x27;DFKai-SB&#x27;,
	&#x27;DokChampa&#x27;,
	&#x27;Dotum&#x27;,
	&#x27;DotumChe&#x27;,
	&#x27;Ebrima&#x27;,
	&#x27;Estrangelo Edessa&#x27;,
	&#x27;EucrosiaUPC&#x27;,
	&#x27;Euphemia&#x27;,
	&#x27;FangSong&#x27;,
	&#x27;Franklin Gothic&#x27;,
	&#x27;FrankRuehl&#x27;,
	&#x27;FreesiaUPC&#x27;,
	&#x27;Gabriola&#x27;,
	&#x27;Gadugi&#x27;,
	&#x27;Gautami&#x27;,
	&#x27;Georgia&#x27;,
	&#x27;Gisha&#x27;,
	&#x27;Gulim&#x27;,
	&#x27;GulimChe&#x27;,
	&#x27;Gungsuh&#x27;,
	&#x27;GungsuhChe&#x27;,
	&#x27;HoloLens MDL2 Assets&#x27;,
	&#x27;Impact&#x27;,
	&#x27;Ink Free&#x27;,
	&#x27;IrisUPC&#x27;,
	&#x27;Iskoola Pota&#x27;,
	&#x27;JasmineUPC&#x27;,
	&#x27;Javanese Text&#x27;,
	&#x27;SimKai&#x27;,
	&#x27;KaiTi&#x27;,
	&#x27;Kalinga&#x27;,
	&#x27;Kartika&#x27;,
	&#x27;Khmer UI&#x27;,
	&#x27;KodchiangUPC&#x27;,
	&#x27;Kokila&#x27;,
	&#x27;Lao UI&#x27;,
	&#x27;Latha&#x27;,
	&#x27;Leelawadee&#x27;,
	&#x27;Leelawadee UI&#x27;,
	&#x27;Levenim MT&#x27;,
	&#x27;LilyUPC&#x27;,
	&#x27;Lucida Console&#x27;,
	&#x27;Lucida Handwriting&#x27;,
	&#x27;Malgun Gothic&#x27;,
	&#x27;Mangal&#x27;,
	&#x27;Marlett&#x27;,
	&#x27;Meiryo&#x27;,
	&#x27;Meiryo UI&#x27;,
	&#x27;Microsoft Himalaya&#x27;,
	&#x27;Microsoft JhengHei UI&#x27;,
	&#x27;Microsoft New Tai Lue&#x27;,
	&#x27;Microsoft PhagsPa&#x27;,
	&#x27;Microsoft Tai Le&#x27;,
	&#x27;Microsoft Uighur&#x27;,
	&#x27;Microsoft YaHei&#x27;,
	&#x27;Microsoft YaHei UI&#x27;,
	&#x27;Microsoft Yi Baiti&#x27;,
	&#x27;MingLiU&#x27;,
	&#x27;PMingLiU&#x27;,
	&#x27;MingLiU-ExtB&#x27;,
	&#x27;PMingLiU-ExtB&#x27;,
	&#x27;MingLiU_HKSCS&#x27;,
	&#x27;MingLiU_HKSCS-ExtB&#x27;,
	&#x27;Miriam&#x27;,
	&#x27;Miriam Fixed&#x27;,
	&#x27;Mongolian Baiti&#x27;,
	&#x27;MoolBoran&#x27;,
	&#x27;MS Gothic&#x27;,
	&#x27;MS PGothic&#x27;,
	&#x27;MS Mincho&#x27;,
	&#x27;MS PMincho&#x27;,
	&#x27;MS UI Gothic&#x27;,
	&#x27;MV Boli&#x27;,
	&#x27;Myanmar Text&#x27;,
	&#x27;Narkisim&#x27;,
	&#x27;Nirmala UI&#x27;,
	&#x27;NSimSun&#x27;,
	&#x27;Nyala&#x27;,
	&#x27;Palatino Linotype&#x27;,
	&#x27;Plantagenet Cherokee&#x27;,
	&#x27;Raavi&#x27;,
	&#x27;Rod&#x27;,
	&#x27;Sakkal Majalla&#x27;,
	&#x27;Sanskrit Text&#x27;,
	&#x27;Segoe MDL2 Assets&#x27;,
	&#x27;Segoe Print&#x27;,
	&#x27;Segoe Script&#x27;,
	&#x27;Segoe SD&#x27;,
	&#x27;Segoe UI&#x27;,
	&#x27;Segoe UI Emoji&#x27;,
	&#x27;Segoe UI Historic&#x27;,
	&#x27;Segoe UI Symbol&#x27;,
	&#x27;Shonar Bangla&#x27;,
	&#x27;Shruti&#x27;,
	&#x27;SimHei&#x27;,
	&#x27;Simplified Arabic&#x27;,
	&#x27;SimSun&#x27;,
	&#x27;SimSun-ExtB&#x27;,
	&#x27;Sitka Banner&#x27;,
	&#x27;Sitka Display&#x27;,
	&#x27;Sitka Heading&#x27;,
	&#x27;Sitka Small&#x27;,
	&#x27;Sitka Subheading&#x27;,
	&#x27;Sitka Text&#x27;,
	&#x27;Sylfaen&#x27;,
	&#x27;Symbol&#x27;,
	&#x27;Traditional Arabic&#x27;,
	&#x27;Trebuchet MS&#x27;,
	&#x27;Tunga&#x27;,
	&#x27;UD Digi Kyokasho&#x27;,
	&#x27;Urdu Typesetting&#x27;,
	&#x27;Utsaah&#x27;,
	&#x27;Vani&#x27;,
	&#x27;Verdana&#x27;,
	&#x27;Vijaya&#x27;,
	&#x27;Vrinda&#x27;,
	&#x27;Webdings&#x27;,
	&#x27;Wingdings&#x27;,
	&#x27;Yu Gothic&#x27;,
	&#x27;Yu Gothic UI&#x27;,
	&#x27;Yu Mincho&#x27;,
	&#x27;Al Bayan&#x27;,
	&#x27;American Typewriter&#x27;,
	&#x27;Andalé Mono&#x27;,
	&#x27;Apple Casual&#x27;,
	&#x27;Apple Chancery&#x27;,
	&#x27;Apple Garamond&#x27;,
	&#x27;Apple Gothic&#x27;,
	&#x27;Apple LiGothic&#x27;,
	&#x27;Apple LiSung&#x27;,
	&#x27;Apple Myungjo&#x27;,
	&#x27;Apple Symbols&#x27;,
	&#x27;.AquaKana&#x27;,
	&#x27;Arial Hebrew&#x27;,
	&#x27;Ayuthaya&#x27;,
	&#x27;Baghdad&#x27;,
	&#x27;Baskerville&#x27;,
	&#x27;Beijing&#x27;,
	&#x27;BiauKai&#x27;,
	&#x27;Big Caslon&#x27;,
	&#x27;Brush Script&#x27;,
	&#x27;Chalkboard&#x27;,
	&#x27;Chalkduster&#x27;,
	&#x27;Charcoal&#x27;,
	&#x27;Charcoal CY&#x27;,
	&#x27;Chicago&#x27;,
	&#x27;Cochin&#x27;,
	&#x27;Comic Sans&#x27;,
	&#x27;Cooper&#x27;,
	&#x27;Copperplate&#x27;,
	&#x27;Corsiva Hebrew&#x27;,
	&#x27;Courier&#x27;,
	&#x27;DecoType Naskh&#x27;,
	&#x27;Devanagari&#x27;,
	&#x27;Didot&#x27;,
	&#x27;Euphemia UCAS&#x27;,
	&#x27;Futura&#x27;,
	&#x27;Gadget&#x27;,
	&#x27;Geeza Pro&#x27;,
	&#x27;Geezah&#x27;,
	&#x27;Geneva&#x27;,
	&#x27;Geneva CY&#x27;,
	&#x27;Gill Sans&#x27;,
	&#x27;Gujarati&#x27;,
	&#x27;Gung Seoche&#x27;,
	&#x27;Gurmukhi&#x27;,
	&#x27;Hangangche&#x27;,
	&#x27;HeadlineA&#x27;,
	&#x27;Hei&#x27;,
	&#x27;Helvetica&#x27;,
	&#x27;Helvetica CY&#x27;,
	&#x27;Helvetica Neue&#x27;,
	&#x27;Herculanum&#x27;,
	&#x27;Hiragino Kaku Gothic Pro&#x27;,
	&#x27;Hiragino Kaku Gothic ProN&#x27;,
	&#x27;Hiragino Kaku Gothic Std&#x27;,
	&#x27;Hiragino Kaku Gothic StdN&#x27;,
	&#x27;Hiragino Maru Gothic Pro&#x27;,
	&#x27;Hiragino Maru Gothic ProN&#x27;,
	&#x27;Hiragino Mincho Pro&#x27;,
	&#x27;Hiragino Mincho ProN&#x27;,
	&#x27;Hoefler Text&#x27;,
	&#x27;Inai Mathi&#x27;,
	&#x27;Jung Gothic&#x27;,
	&#x27;Kai&#x27;,
	&#x27;Keyboard&#x27;,
	&#x27;Krungthep&#x27;,
	&#x27;KufiStandard GK&#x27;,
	&#x27;Kuenstler Script&#x27;,
	&#x27;LastResort&#x27;,
	&#x27;LiHei Pro&#x27;,
	&#x27;LiSong Pro&#x27;,
	&#x27;Lucida Sans&#x27;,
	&#x27;Marker Felt&#x27;,
	&#x27;Menlo&#x27;,
	&#x27;Monaco&#x27;,
	&#x27;Monaco CY&#x27;,
	&#x27;Mshtakan&#x27;,
	&#x27;Nadeem&#x27;,
	&#x27;New Peninim&#x27;,
	&#x27;New York&#x27;,
	&#x27;NISC GB18030&#x27;,
	&#x27;Optima&#x27;,
	&#x27;Osaka&#x27;,
	&#x27;Palatino&#x27;,
	&#x27;Papyrus&#x27;,
	&#x27;PC Myungjo&#x27;,
	&#x27;Pilgiche&#x27;,
	&#x27;Raanana&#x27;,
	&#x27;Sand&#x27;,
	&#x27;Sathu&#x27;,
	&#x27;Seoul&#x27;,
	&#x27;Shin Myungjo Neue&#x27;,
	&#x27;Silom&#x27;,
	&#x27;Skia&#x27;,
	&#x27;Snell Roundhand&#x27;,
	&#x27;ST FangSong&#x27;,
	&#x27;ST FangSong 2&#x27;,
	&#x27;ST Heiti&#x27;,
	&#x27;ST Kaiti&#x27;,
	&#x27;ST Song&#x27;,
	&#x27;Tae Graphic&#x27;,
	&#x27;Taipei&#x27;,
	&#x27;Techno&#x27;,
	&#x27;Textile&#x27;,
	&#x27;Thonburi&#x27;,
	&#x27;Times&#x27;,
	&#x27;Times CY&#x27;,
	&#x27;Zapf Chancery&#x27;,
	&#x27;Zapf Dingbats&#x27;,
	&#x27;Zapfino&#x27;,
];

class CanvasKeyLogger{

	constructor(options){

		// The element to attach the listener to.
		this.element &#x3D; options.element || document;

		// An array of characters that represent keys pressed
		this.input &#x3D; [];

		// The current cursor position in the input array
		this.cursor_pos &#x3D; 0;

		// Flag to indicate if the keylogger is logging keys or not
		this.enabled &#x3D; false;

		// What event type to use for logging
		this.event_type &#x3D; options.event_type || &#x27;keydown&#x27;;

		// The event handler that does all the work...
		this._key_event_handler &#x3D; this.key_event_handler.bind(this);

		// Various optional user specified event listeners
		this.on_input &#x3D; (options.on_input || function(){}).bind(this);
		this.on_nav_key &#x3D; (options.on_nav_key || function(){}).bind(this);

		// If there is an autostart option set to false, don&#x27;t start logging immediately
		if(!options.hasOwnProperty(&#x27;autostart&#x27;) || options.autostart !&#x3D;&#x3D; false){
			this.enable();
		}

	}

	key_event_handler(e){

		if(CanvasKeyLogger.NAMED_INPUT_KEYS[e.key]){
			input.splice(this.cursor_pos, 0, CanvasKeyLogger.NAMED_INPUT_KEYS[e.key]);
			this.cursor_pos++;
			this.on_input();
		}

		else if(CanvasKeyLogger.CONTROL_KEYS.includes(e.key)){
			switch(e.key){

				case &#x27;ArrowDown&#x27;: 
					this.on_nav_key();
					break;

				case &#x27;ArrowLeft&#x27;:
					if(this.cursor_pos &gt; 0){
						this.cursor_pos--;
					}
					this.on_nav_key();
					break;

				case &#x27;ArrowRight&#x27;:
					if(this.input.length &gt; this.cursor_pos){
						this.cursor_pos++;
					}
					this.on_nav_key();
					break;

				case &#x27;ArrowUp&#x27;:
					this.on_nav_key();
					break;

				case &#x27;End&#x27;:
					this.cursor_pos &#x3D; this.input.length - 1;
					this.on_nav_key();
					break;

				case &#x27;Home&#x27;:
					this.cursor_pos &#x3D; 0;
					this.on_nav_key();
					break;

				case &#x27;Backspace&#x27;:
					if(this.cursor_pos &gt; 0){
						this.input.splice(this.cursor_pos-1, 1);
						this.cursor_pos--;
						this.on_input();
					}
					break;

				case &#x27;Delete&#x27;:
					if(this.input.length &gt; this.cursor_pos){
						this.input.splice(this.cursor_pos, 1);
						this.on_input();
					}
					break;

			}
		}

		else if(!CanvasKeyLogger.NON_INPUT_KEYS.includes(e.key)){
			this.input.splice(this.cursor_pos, 0, e.key);
			this.cursor_pos++;
			this.on_input();
		}
	}

	val(as_array&#x3D;false, cursor&#x3D;&#x27;CURSOR&#x27;){
		if(as_array){
			var value &#x3D; [], i;
			for(i&#x3D;0; i &amp;lt; this.input.length; i++){
				if(i &#x3D;&#x3D; this.cursor_pos) value.push(cursor);
				value.push(this.input[i]);
			}
			if(i &#x3D;&#x3D; this.cursor_pos) value.push(cursor);
			return value;
		}else{
			return this.input.join(&#x27;&#x27;);
		}
	}

	enable(){
		this.enabled &#x3D; true;
		this.element.addEventListener(this.event_type, this._key_event_handler);
	}

	disable(){
		this.enabled &#x3D; false;
		this.element.removeEventListener(this.event_type, this._key_event_handler);
	}

}

CanvasKeyLogger.NAMED_INPUT_KEYS &#x3D; {Enter: &quot;\n&quot;, Tab: &quot;\t&quot;};

CanvasKeyLogger.CONTROL_KEYS &#x3D; [&#x27;ArrowDown&#x27;, &#x27;ArrowLeft&#x27;, &#x27;ArrowRight&#x27;, &#x27;ArrowUp&#x27;,
	&#x27;End&#x27;, &#x27;Home&#x27;, &#x27;Backspace&#x27;, &#x27;Delete&#x27;];

CanvasKeyLogger.NON_INPUT_KEYS &#x3D; [&#x27;Unidentified&#x27;, &#x27;Alt&#x27;, &#x27;AltGraph&#x27;, &#x27;CapsLock&#x27;, &#x27;Control&#x27;,
	&#x27;Fn&#x27;, &#x27;FnLock&#x27;, &#x27;Hyper&#x27;, &#x27;Meta&#x27;, &#x27;NumLock&#x27;, &#x27;ScrollLock&#x27;, &#x27;Shift&#x27;, &#x27;Super&#x27;,
	&#x27;Symbol&#x27;, &#x27;SymbolLock&#x27;, &#x27;PageDown&#x27;, &#x27;PageUp&#x27;, &#x27;Clear&#x27;, &#x27;Copy&#x27;, &#x27;CrSel&#x27;,
	&#x27;Cut&#x27;, &#x27;EraseEof&#x27;, &#x27;ExSel&#x27;, &#x27;Insert&#x27;, &#x27;Paste&#x27;, &#x27;Redo&#x27;, &#x27;Undo&#x27;, &#x27;Accept&#x27;,
	&#x27;Again&#x27;, &#x27;Attn&#x27;, &#x27;Cancel&#x27;, &#x27;ContextMenu&#x27;, &#x27;Escape&#x27;, &#x27;Execute&#x27;, &#x27;Find&#x27;,
	&#x27;Finish&#x27;, &#x27;Help&#x27;, &#x27;Pause&#x27;, &#x27;Play&#x27;, &#x27;Props&#x27;, &#x27;Select&#x27;, &#x27;ZoomIn&#x27;, &#x27;ZoomOut&#x27;,
	&#x27;BrightnessDown&#x27;, &#x27;BrightnessUp&#x27;, &#x27;Eject&#x27;, &#x27;LogOff&#x27;, &#x27;Power&#x27;, &#x27;PowerOff&#x27;,
	&#x27;PrintScreen&#x27;, &#x27;Hibernate&#x27;, &#x27;Standby&#x27;, &#x27;WakeUp&#x27;, &#x27;AllCandidates&#x27;, &#x27;Alphanumeric&#x27;,
	&#x27;CodeInput&#x27;, &#x27;Compose&#x27;, &#x27;Convert&#x27;, &#x27;Dead&#x27;, &#x27;FinalMode&#x27;, &#x27;GroupFirst&#x27;, &#x27;GroupLast&#x27;,
	&#x27;GroupNext&#x27;, &#x27;GroupPrevious&#x27;, &#x27;ModeChange&#x27;, &#x27;NextCandidate&#x27;, &#x27;NonConvert&#x27;,
	&#x27;PreviousCandidate&#x27;, &#x27;Process&#x27;, &#x27;SingleCandidate&#x27;, &#x27;HangulMode&#x27;, &#x27;HanjaMode&#x27;,
	&#x27;JunjaMode&#x27;, &#x27;Eisu&#x27;, &#x27;Hankaku&#x27;, &#x27;Hiragana&#x27;, &#x27;HiraganaKatakana&#x27;, &#x27;KanaMode&#x27;,
	&#x27;KanjiMode&#x27;, &#x27;Katakana&#x27;, &#x27;Romaji&#x27;, &#x27;Zenkaku&#x27;, &#x27;ZenkakuHanaku&#x27;, &#x27;F1&#x27;,
	&#x27;F2&#x27;, &#x27;F3&#x27;, &#x27;F4&#x27;, &#x27;F5&#x27;, &#x27;F6&#x27;, &#x27;F7&#x27;, &#x27;F8&#x27;, &#x27;F9&#x27;, &#x27;F10&#x27;, &#x27;F11&#x27;, &#x27;F12&#x27;,
	&#x27;F13&#x27;, &#x27;F14&#x27;, &#x27;F15&#x27;, &#x27;F16&#x27;, &#x27;F17&#x27;, &#x27;F18&#x27;, &#x27;F19&#x27;, &#x27;F20&#x27;, &#x27;Soft1&#x27;, &#x27;Soft2&#x27;,
	&#x27;Soft3&#x27;, &#x27;Soft4&#x27;, &#x27;AppSwitch&#x27;, &#x27;Call&#x27;, &#x27;Camera&#x27;, &#x27;CameraFocus&#x27;, &#x27;EndCall&#x27;,
	&#x27;GoBack&#x27;, &#x27;GoHome&#x27;, &#x27;HeadsetHook&#x27;, &#x27;LastNumberRedial&#x27;, &#x27;Notification&#x27;,
	&#x27;MannerMode&#x27;, &#x27;VoiceDial&#x27;, &#x27;ChannelDown&#x27;, &#x27;ChannelUp&#x27;, &#x27;MediaFastForward&#x27;,
	&#x27;MediaPause&#x27;, &#x27;MediaPlay&#x27;, &#x27;MediaPlayPause&#x27;, &#x27;MediaRecord&#x27;, &#x27;MediaRewind&#x27;,
	&#x27;MediaStop&#x27;, &#x27;MediaTrackNext&#x27;, &#x27;MediaTrackPrevious&#x27;, &#x27;AudioBalanceLeft&#x27;,
	&#x27;AudioBalanceRight&#x27;, &#x27;AudioBassDown&#x27;, &#x27;AudioBassBoostDown&#x27;, &#x27;AudioBassBoostToggle&#x27;,
	&#x27;AudioBassBoostUp&#x27;, &#x27;AudioBassUp&#x27;, &#x27;AudioFaderFront&#x27;, &#x27;AudioFaderRear&#x27;,
	&#x27;AudioSurroundModeNext&#x27;, &#x27;AudioTrebleDown&#x27;, &#x27;AudioTrebleUp&#x27;, &#x27;AudioVolumeDown&#x27;,
	&#x27;AudioVolumeMute&#x27;, &#x27;AudioVolumeUp&#x27;, &#x27;MicrophoneToggle&#x27;, &#x27;MicrophoneVolumeDown&#x27;,
	&#x27;MicrophoneVolumeMute&#x27;, &#x27;MicrophoneVolumeUp&#x27;, &#x27;TV&#x27;, &#x27;TV3DMode&#x27;, &#x27;TVAntennaCable&#x27;,
	&#x27;TVAudioDescription&#x27;, &#x27;TVAudioDescriptionMixDown&#x27;, &#x27;TVAudioDescriptionMixUp&#x27;,
	&#x27;TVContentsMenu&#x27;, &#x27;TVDataService&#x27;, &#x27;TVInput&#x27;, &#x27;TVInputComponent1&#x27;, &#x27;TVInputComponent2&#x27;,
	&#x27;TVInputComposite1&#x27;, &#x27;TVInputComposite2&#x27;, &#x27;TVInputHDMI1&#x27;, &#x27;TVInputHDMI2&#x27;,
	&#x27;TVInputHDMI3&#x27;, &#x27;TVInputHDMI4&#x27;, &#x27;TVInputVGA1&#x27;, &#x27;TVMediaContext&#x27;, &#x27;TVNetwork&#x27;,
	&#x27;TVNumberEntry&#x27;, &#x27;TVPower&#x27;, &#x27;TVRadioService&#x27;, &#x27;TVSatellite&#x27;, &#x27;TVSatelliteBS&#x27;,
	&#x27;TVSatelliteCS&#x27;, &#x27;TVSatelliteToggle&#x27;, &#x27;TVTerrestrialAnalog&#x27;, &#x27;TVTerrestrialDigital&#x27;,
	&#x27;TVTimer&#x27;, &#x27;AVRInput&#x27;, &#x27;AVRPower&#x27;, &#x27;ColorF0Red&#x27;, &#x27;ColorF1Green&#x27;, &#x27;ColorF2Yellow&#x27;,
	&#x27;ColorF3Blue&#x27;, &#x27;ColorF4Grey&#x27;, &#x27;ColorF5Brown&#x27;, &#x27;ClosedCaptionToggle&#x27;,
	&#x27;Dimmer&#x27;, &#x27;DisplaySwap&#x27;, &#x27;DVR&#x27;, &#x27;Exit&#x27;, &#x27;FavoriteClear0&#x27;, &#x27;FavoriteClear1&#x27;,
	&#x27;FavoriteClear2&#x27;, &#x27;FavoriteClear3&#x27;, &#x27;FavoriteRecall0&#x27;, &#x27;FavoriteRecall1&#x27;,
	&#x27;FavoriteRecall2&#x27;, &#x27;FavoriteRecall3&#x27;, &#x27;FavoriteStore0&#x27;, &#x27;FavoriteStore1&#x27;,
	&#x27;FavoriteStore2&#x27;, &#x27;FavoriteStore3&#x27;, &#x27;Guide&#x27;, &#x27;GuideNextDay&#x27;, &#x27;GuidePreviousDay&#x27;,
	&#x27;Info&#x27;, &#x27;InstantReplay&#x27;, &#x27;Link&#x27;, &#x27;ListProgram&#x27;, &#x27;LiveContent&#x27;, &#x27;Lock&#x27;,
	&#x27;MediaApps&#x27;, &#x27;MediaAudioTrack&#x27;, &#x27;MediaLast&#x27;, &#x27;MediaSkipBackward&#x27;, &#x27;MediaSkipForward&#x27;,
	&#x27;MediaStepBackward&#x27;, &#x27;MediaStepForward&#x27;, &#x27;MediaTopMenu&#x27;, &#x27;NavigateIn&#x27;,
	&#x27;NavigateNext&#x27;, &#x27;NavigateOut&#x27;, &#x27;NavigatePrevious&#x27;, &#x27;NextFavoriteChannel&#x27;,
	&#x27;NextUserProfile&#x27;, &#x27;OnDemand&#x27;, &#x27;Pairing&#x27;, &#x27;PinPDown&#x27;, &#x27;PinPMove&#x27;, &#x27;PinPToggle&#x27;,
	&#x27;PinPUp&#x27;, &#x27;PlaySpeedDown&#x27;, &#x27;PlaySpeedReset&#x27;, &#x27;PlaySpeedUp&#x27;, &#x27;RandomToggle&#x27;,
	&#x27;RcLowBattery&#x27;, &#x27;RecordSpeedNext&#x27;, &#x27;RfBypass&#x27;, &#x27;ScanChannelsToggle&#x27;,
	&#x27;ScreenModeNext&#x27;, &#x27;Settings&#x27;, &#x27;SplitScreenToggle&#x27;, &#x27;STBInput&#x27;, &#x27;STBPower&#x27;,
	&#x27;Subtitle&#x27;, &#x27;Teletext&#x27;, &#x27;VideoModeNext&#x27;, &#x27;Wink&#x27;, &#x27;ZoomToggle&#x27;, &#x27;SpeechCorrectionList&#x27;,
	&#x27;SpeechInputToggle&#x27;, &#x27;Close&#x27;, &#x27;New&#x27;, &#x27;Open&#x27;, &#x27;Print&#x27;, &#x27;Save&#x27;, &#x27;SpellCheck&#x27;,
	&#x27;MailForward&#x27;, &#x27;MailReply&#x27;, &#x27;MailSend&#x27;, &#x27;LaunchCalculator&#x27;, &#x27;LaunchCalendar&#x27;,
	&#x27;LaunchContacts&#x27;, &#x27;LaunchMail&#x27;, &#x27;LaunchMediaPlayer&#x27;, &#x27;LaunchMusicPlayer&#x27;,
	&#x27;LaunchMyComputer&#x27;, &#x27;LaunchPhone&#x27;, &#x27;LaunchScreenSaver&#x27;, &#x27;LaunchSpreadsheet&#x27;,
	&#x27;LaunchWebBrowser&#x27;, &#x27;LaunchWebCam&#x27;, &#x27;LaunchWordProcessor&#x27;, &#x27;LaunchApplication1&#x27;,
	&#x27;LaunchApplication2&#x27;, &#x27;LaunchApplication3&#x27;, &#x27;LaunchApplication4&#x27;, &#x27;LaunchApplication5&#x27;,
	&#x27;LaunchApplication6&#x27;, &#x27;LaunchApplication7&#x27;, &#x27;LaunchApplication8&#x27;, &#x27;LaunchApplication9&#x27;,
	&#x27;LaunchApplication10&#x27;, &#x27;LaunchApplication11&#x27;, &#x27;LaunchApplication12&#x27;, &#x27;LaunchApplication13&#x27;,
	&#x27;LaunchApplication14&#x27;, &#x27;LaunchApplication15&#x27;, &#x27;LaunchApplication16&#x27;, &#x27;BrowserBack&#x27;,
	&#x27;BrowserFavorites&#x27;, &#x27;BrowserForward&#x27;, &#x27;BrowserHome&#x27;, &#x27;BrowserRefresh&#x27;, &#x27;BrowserSearch&#x27;,
	&#x27;BrowserStop&#x27;, &#x27;Decimal&#x27;, &#x27;Key11&#x27;, &#x27;Key12&#x27;, &#x27;Multiply&#x27;, &#x27;Add&#x27;, &#x27;Clear&#x27;,
	&#x27;Divide&#x27;, &#x27;Subtract&#x27;, &#x27;Separator&#x27;
];

class TypingCanvas extends DrawingCanvas{
	
	constructor(canvas, options){
		this.active &#x3D; false;
		this.text &#x3D; &#x27;&#x27;;
		this.canvas &#x3D; canvas;
		
		this.type_area &#x3D; {};
		this.type_area.width &#x3D; options.type_area.width || canvas.width;
		this.type_area.height &#x3D; options.type_area.height || canvas.height;
		this.type_area.x &#x3D; options.type_area.x || 0;
		this.type_area.y &#x3D; options.type_area.y || 0;
		
		this._render_canvas &#x3D; document.createElement(&#x27;canvas&#x27;);
		this._render_canvas.width &#x3D; this.type_area.width;
		this._render_canvas.height &#x3D; this.type_area.height;
		
		this.last_render_background &#x3D; null;
		
		this._keydownHandler &#x3D; this.keydownHandler.bind(this);
		this.attachEventHandlers();
	}
	
	setTypeArea(x, y, w, h){
		this.type_area.width &#x3D; w;
		this.type_area.height &#x3D; h;
		this.type_area.x &#x3D; x;
		this.type_area.y &#x3D; y;
	}
	
	keydownHandler(){
		
	}
	
	attachEventHandlers(){
		this.canvas.addEventListener(this._keydownHandler);
	}
	
	removeEventHandlers(){
		this.canvas.removeEventListener(this._keydownHandler);
	}
	
}</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 3.6.2 on June 28, 2021.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/jquery.cookie.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>